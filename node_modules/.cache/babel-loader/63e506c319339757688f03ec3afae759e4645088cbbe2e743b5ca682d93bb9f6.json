{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\nimport { WebPlugin, buildRequestInit } from '@capacitor/core';\nimport { Encoding } from './definitions';\nfunction resolve(path) {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix = [];\n  posix.forEach(item => {\n    if (item === '..' && newPosix.length > 0 && newPosix[newPosix.length - 1] !== '..') {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n  return newPosix.join('/');\n}\nfunction isPathParent(parent, children) {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n  return parent !== children && pathsA.every((value, index) => value === pathsB[index]);\n}\nexport class FilesystemWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.DB_VERSION = 1;\n    this.DB_NAME = 'Disc';\n    this._writeCmds = ['add', 'put', 'delete'];\n    /**\n     * Function that performs a http request to a server and downloads the file to the specified destination\n     *\n     * @param options the options for the download operation\n     * @returns a promise that resolves with the download file result\n     */\n    this.downloadFile = async options => {\n      var _a, _b;\n      const requestInit = buildRequestInit(options, options.webFetchExtra);\n      const response = await fetch(options.url, requestInit);\n      let blob;\n      if (!options.progress) blob = await response.blob();else if (!(response === null || response === void 0 ? void 0 : response.body)) blob = new Blob();else {\n        const reader = response.body.getReader();\n        let bytes = 0;\n        const chunks = [];\n        const contentType = response.headers.get('content-type');\n        const contentLength = parseInt(response.headers.get('content-length') || '0', 10);\n        while (true) {\n          const {\n            done,\n            value\n          } = await reader.read();\n          if (done) break;\n          chunks.push(value);\n          bytes += (value === null || value === void 0 ? void 0 : value.length) || 0;\n          const status = {\n            url: options.url,\n            bytes,\n            contentLength\n          };\n          this.notifyListeners('progress', status);\n        }\n        const allChunks = new Uint8Array(bytes);\n        let position = 0;\n        for (const chunk of chunks) {\n          if (typeof chunk === 'undefined') continue;\n          allChunks.set(chunk, position);\n          position += chunk.length;\n        }\n        blob = new Blob([allChunks.buffer], {\n          type: contentType || undefined\n        });\n      }\n      const result = await this.writeFile({\n        path: options.path,\n        directory: (_a = options.directory) !== null && _a !== void 0 ? _a : undefined,\n        recursive: (_b = options.recursive) !== null && _b !== void 0 ? _b : false,\n        data: blob\n      });\n      return {\n        path: result.uri,\n        blob\n      };\n    };\n  }\n  async initDb() {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n  static doUpgrade(event) {\n    const eventTarget = event.target;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default:\n        {\n          if (db.objectStoreNames.contains('FileStorage')) {\n            db.deleteObjectStore('FileStorage');\n          }\n          const store = db.createObjectStore('FileStorage', {\n            keyPath: 'path'\n          });\n          store.createIndex('by_folder', 'folder');\n        }\n    }\n  }\n  async dbRequest(cmd, args) {\n    const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then(conn => {\n      return new Promise((resolve, reject) => {\n        const tx = conn.transaction(['FileStorage'], readFlag);\n        const store = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n  async dbIndexRequest(indexName, cmd, args) {\n    const readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then(conn => {\n      return new Promise((resolve, reject) => {\n        const tx = conn.transaction(['FileStorage'], readFlag);\n        const store = tx.objectStore('FileStorage');\n        const index = store.index(indexName);\n        const req = index[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n  getPath(directory, uriPath) {\n    const cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n  async clear() {\n    const conn = await this.initDb();\n    const tx = conn.transaction(['FileStorage'], 'readwrite');\n    const store = tx.objectStore('FileStorage');\n    store.clear();\n  }\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n    const entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) throw Error('File does not exist.');\n    return {\n      data: entry.content ? entry.content : ''\n    };\n  }\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const doRecursive = options.recursive;\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (occupiedEntry && occupiedEntry.type === 'directory') throw Error('The supplied path is a directory.');\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive\n        });\n      }\n    }\n    if (!encoding && !(data instanceof Blob)) {\n      data = data.indexOf(',') >= 0 ? data.split(',')[1] : data;\n      if (!this.isBase64String(data)) throw Error('The supplied data is not valid base64 content.');\n    }\n    const now = Date.now();\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data instanceof Blob ? data.size : data.length,\n      ctime: now,\n      mtime: now,\n      content: data\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path\n    };\n  }\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const now = Date.now();\n    let ctime = now;\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (occupiedEntry && occupiedEntry.type === 'directory') throw Error('The supplied path is a directory.');\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true\n        });\n      }\n    }\n    if (!encoding && !this.isBase64String(data)) throw Error('The supplied data is not valid base64 content.');\n    if (occupiedEntry !== undefined) {\n      if (occupiedEntry.content instanceof Blob) {\n        throw Error('The occupied entry contains a Blob object which cannot be appended to.');\n      }\n      if (occupiedEntry.content !== undefined && !encoding) {\n        data = btoa(atob(occupiedEntry.content) + atob(data));\n      } else {\n        data = occupiedEntry.content + data;\n      }\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options) {\n    const path = this.getPath(options.directory, options.path);\n    const entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n    await this.dbRequest('delete', [path]);\n  }\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options) {\n    const path = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = await this.dbRequest('get', [parentPath]);\n    const occupiedEntry = await this.dbRequest('get', [path]);\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined) throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined) throw Error('Parent directory must exist');\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive\n      });\n    }\n    const now = Date.now();\n    const pathObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options) {\n    const {\n      path,\n      directory,\n      recursive\n    } = options;\n    const fullPath = this.getPath(directory, path);\n    const entry = await this.dbRequest('get', [fullPath]);\n    if (entry === undefined) throw Error('Folder does not exist.');\n    if (entry.type !== 'directory') throw Error('Requested path is not a directory');\n    const readDirResult = await this.readdir({\n      path,\n      directory\n    });\n    if (readDirResult.files.length !== 0 && !recursive) throw Error('Folder is not empty');\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry.name}`;\n      const entryObj = await this.stat({\n        path: entryPath,\n        directory\n      });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({\n          path: entryPath,\n          directory\n        });\n      } else {\n        await this.rmdir({\n          path: entryPath,\n          directory,\n          recursive\n        });\n      }\n    }\n    await this.dbRequest('delete', [fullPath]);\n  }\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options) {\n    const path = this.getPath(options.directory, options.path);\n    const entry = await this.dbRequest('get', [path]);\n    if (options.path !== '' && entry === undefined) throw Error('Folder does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);\n    const files = await Promise.all(entries.map(async e => {\n      let subEntry = await this.dbRequest('get', [e]);\n      if (subEntry === undefined) {\n        subEntry = await this.dbRequest('get', [e + '/']);\n      }\n      return {\n        name: e.substring(path.length + 1),\n        type: subEntry.type,\n        size: subEntry.size,\n        ctime: subEntry.ctime,\n        mtime: subEntry.mtime,\n        uri: subEntry.path\n      };\n    }));\n    return {\n      files: files\n    };\n  }\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options) {\n    const path = this.getPath(options.directory, options.path);\n    let entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) {\n      entry = await this.dbRequest('get', [path + '/']);\n    }\n    return {\n      uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path\n    };\n  }\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options) {\n    const path = this.getPath(options.directory, options.path);\n    let entry = await this.dbRequest('get', [path]);\n    if (entry === undefined) {\n      entry = await this.dbRequest('get', [path + '/']);\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path\n    };\n  }\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options) {\n    await this._copy(options, true);\n    return;\n  }\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options) {\n    return this._copy(options, false);\n  }\n  async requestPermissions() {\n    return {\n      publicStorage: 'granted'\n    };\n  }\n  async checkPermissions() {\n    return {\n      publicStorage: 'granted'\n    };\n  }\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  async _copy(options, doRename = false) {\n    let {\n      toDirectory\n    } = options;\n    const {\n      to,\n      from,\n      directory: fromDirectory\n    } = options;\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return {\n        uri: toPath\n      };\n    }\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory\n        });\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory\n    });\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path, ctime, mtime) => {\n      const fullPath = this.getPath(toDirectory, path);\n      const entry = await this.dbRequest('get', [fullPath]);\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file':\n        {\n          // Read the file\n          const file = await this.readFile({\n            path: from,\n            directory: fromDirectory\n          });\n          // Optionally remove the file\n          if (doRename) {\n            await this.deleteFile({\n              path: from,\n              directory: fromDirectory\n            });\n          }\n          let encoding;\n          if (!(file.data instanceof Blob) && !this.isBase64String(file.data)) {\n            encoding = Encoding.UTF8;\n          }\n          // Write the file to the new location\n          const writeResult = await this.writeFile({\n            path: to,\n            directory: toDirectory,\n            data: file.data,\n            encoding: encoding\n          });\n          // Copy the mtime/ctime of a renamed file\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n          // Resolve promise\n          return writeResult;\n        }\n      case 'directory':\n        {\n          if (toObj) {\n            throw Error('Cannot move a directory over an existing object');\n          }\n          try {\n            // Create the to directory\n            await this.mkdir({\n              path: to,\n              directory: toDirectory,\n              recursive: false\n            });\n            // Copy the mtime/ctime of a renamed directory\n            if (doRename) {\n              await updateTime(to, ctime, fromObj.mtime);\n            }\n          } catch (e) {\n            // ignore\n          }\n          // Iterate over the contents of the from location\n          const contents = (await this.readdir({\n            path: from,\n            directory: fromDirectory\n          })).files;\n          for (const filename of contents) {\n            // Move item from the from directory to the to directory\n            await this._copy({\n              from: `${from}/${filename.name}`,\n              to: `${to}/${filename.name}`,\n              directory: fromDirectory,\n              toDirectory\n            }, doRename);\n          }\n          // Optionally remove the original from directory\n          if (doRename) {\n            await this.rmdir({\n              path: from,\n              directory: fromDirectory\n            });\n          }\n        }\n    }\n    return {\n      uri: toPath\n    };\n  }\n  isBase64String(str) {\n    try {\n      return btoa(atob(str)) == str;\n    } catch (err) {\n      return false;\n    }\n  }\n}\nFilesystemWeb._debug = true;","map":{"version":3,"names":["WebPlugin","buildRequestInit","Encoding","resolve","path","posix","split","filter","item","newPosix","forEach","length","pop","push","join","isPathParent","parent","children","pathsA","pathsB","every","value","index","FilesystemWeb","constructor","DB_VERSION","DB_NAME","_writeCmds","downloadFile","options","requestInit","webFetchExtra","response","fetch","url","blob","progress","body","Blob","reader","getReader","bytes","chunks","contentType","headers","get","contentLength","parseInt","done","read","status","notifyListeners","allChunks","Uint8Array","position","chunk","set","buffer","type","undefined","result","writeFile","directory","_a","recursive","_b","data","uri","initDb","_db","window","unavailable","Promise","reject","request","indexedDB","open","onupgradeneeded","doUpgrade","onsuccess","onerror","error","onblocked","console","warn","event","eventTarget","target","db","oldVersion","objectStoreNames","contains","deleteObjectStore","store","createObjectStore","keyPath","createIndex","dbRequest","cmd","args","readFlag","indexOf","then","conn","tx","transaction","objectStore","req","dbIndexRequest","indexName","getPath","uriPath","cleanedUriPath","replace","fsPath","clear","readFile","entry","Error","content","encoding","doRecursive","occupiedEntry","parentPath","substr","lastIndexOf","parentEntry","subDirIndex","parentArgPath","mkdir","isBase64String","now","Date","pathObj","folder","size","ctime","mtime","appendFile","btoa","atob","deleteFile","entries","IDBKeyRange","only","depth","match","rmdir","fullPath","readDirResult","readdir","files","entryPath","name","entryObj","stat","all","map","e","subEntry","substring","getUri","rename","_copy","copy","requestPermissions","publicStorage","checkPermissions","doRename","toDirectory","to","from","fromDirectory","fromPath","toPath","toObj","toPathComponents","toParentDirectory","fromObj","updateTime","file","UTF8","writeResult","contents","filename","str","err","_debug"],"sources":["../../src/web.ts"],"sourcesContent":["import { WebPlugin, buildRequestInit } from '@capacitor/core';\n\nimport type {\n  AppendFileOptions,\n  CopyOptions,\n  CopyResult,\n  DeleteFileOptions,\n  FilesystemPlugin,\n  GetUriOptions,\n  GetUriResult,\n  MkdirOptions,\n  PermissionStatus,\n  ReadFileOptions,\n  ReadFileResult,\n  ReaddirOptions,\n  ReaddirResult,\n  RenameOptions,\n  RmdirOptions,\n  StatOptions,\n  StatResult,\n  WriteFileOptions,\n  WriteFileResult,\n  Directory,\n  DownloadFileOptions,\n  DownloadFileResult,\n  ProgressStatus,\n} from './definitions';\nimport { Encoding } from './definitions';\n\nfunction resolve(path: string): string {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix: string[] = [];\n\n  posix.forEach(item => {\n    if (\n      item === '..' &&\n      newPosix.length > 0 &&\n      newPosix[newPosix.length - 1] !== '..'\n    ) {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n\n  return newPosix.join('/');\n}\nfunction isPathParent(parent: string, children: string): boolean {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n\n  return (\n    parent !== children &&\n    pathsA.every((value, index) => value === pathsB[index])\n  );\n}\n\nexport class FilesystemWeb extends WebPlugin implements FilesystemPlugin {\n  DB_VERSION = 1;\n  DB_NAME = 'Disc';\n\n  private _writeCmds: string[] = ['add', 'put', 'delete'];\n  private _db?: IDBDatabase;\n  static _debug = true;\n  async initDb(): Promise<IDBDatabase> {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event: IDBVersionChangeEvent): void {\n    const eventTarget = event.target as IDBOpenDBRequest;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default: {\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n        store.createIndex('by_folder', 'folder');\n      }\n    }\n  }\n\n  async dbRequest(cmd: string, args: any[]): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: any = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(\n    indexName: string,\n    cmd: string,\n    args: [any],\n  ): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: IDBObjectStore = tx.objectStore('FileStorage');\n        const index: any = store.index(indexName);\n        const req = index[cmd](...args) as any;\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  private getPath(\n    directory: Directory | undefined,\n    uriPath: string | undefined,\n  ): string {\n    const cleanedUriPath =\n      uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear(): Promise<void> {\n    const conn: IDBDatabase = await this.initDb();\n    const tx: IDBTransaction = conn.transaction(['FileStorage'], 'readwrite');\n    const store: IDBObjectStore = tx.objectStore('FileStorage');\n    store.clear();\n  }\n\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options: ReadFileOptions): Promise<ReadFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    return { data: entry.content ? entry.content : '' };\n  }\n\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options: WriteFileOptions): Promise<WriteFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const doRecursive = options.recursive;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive,\n        });\n      }\n    }\n\n    if (!encoding && !(data instanceof Blob)) {\n      data = data.indexOf(',') >= 0 ? data.split(',')[1] : data;\n      if (!this.isBase64String(data))\n        throw Error('The supplied data is not valid base64 content.');\n    }\n\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data instanceof Blob ? data.size : data.length,\n      ctime: now,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path,\n    };\n  }\n\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options: AppendFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const now = Date.now();\n    let ctime = now;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true,\n        });\n      }\n    }\n\n    if (!encoding && !this.isBase64String(data))\n      throw Error('The supplied data is not valid base64 content.');\n\n    if (occupiedEntry !== undefined) {\n      if (occupiedEntry.content instanceof Blob) {\n        throw Error(\n          'The occupied entry contains a Blob object which cannot be appended to.',\n        );\n      }\n\n      if (occupiedEntry.content !== undefined && !encoding) {\n        data = btoa(atob(occupiedEntry.content) + atob(data));\n      } else {\n        data = occupiedEntry.content + data;\n      }\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options: DeleteFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n      IDBKeyRange.only(path),\n    ]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n\n    await this.dbRequest('delete', [path]);\n  }\n\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options: MkdirOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined)\n      throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined)\n      throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive,\n      });\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options: RmdirOptions): Promise<void> {\n    const { path, directory, recursive } = options;\n    const fullPath: string = this.getPath(directory, path);\n\n    const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n\n    if (entry === undefined) throw Error('Folder does not exist.');\n\n    if (entry.type !== 'directory')\n      throw Error('Requested path is not a directory');\n\n    const readDirResult = await this.readdir({ path, directory });\n\n    if (readDirResult.files.length !== 0 && !recursive)\n      throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry.name}`;\n      const entryObj = await this.stat({ path: entryPath, directory });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({ path: entryPath, directory });\n      } else {\n        await this.rmdir({ path: entryPath, directory, recursive });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options: ReaddirOptions): Promise<ReaddirResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (options.path !== '' && entry === undefined)\n      throw Error('Folder does not exist.');\n\n    const entries: string[] = await this.dbIndexRequest(\n      'by_folder',\n      'getAllKeys',\n      [IDBKeyRange.only(path)],\n    );\n    const files = await Promise.all(\n      entries.map(async e => {\n        let subEntry = (await this.dbRequest('get', [e])) as EntryObj;\n        if (subEntry === undefined) {\n          subEntry = (await this.dbRequest('get', [e + '/'])) as EntryObj;\n        }\n        return {\n          name: e.substring(path.length + 1),\n          type: subEntry.type,\n          size: subEntry.size,\n          ctime: subEntry.ctime,\n          mtime: subEntry.mtime,\n          uri: subEntry.path,\n        };\n      }),\n    );\n    return { files: files };\n  }\n\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options: GetUriOptions): Promise<GetUriResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    return {\n      uri: entry?.path || path,\n    };\n  }\n\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options: StatOptions): Promise<StatResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path,\n    };\n  }\n\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options: RenameOptions): Promise<void> {\n    await this._copy(options, true);\n    return;\n  }\n\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options: CopyOptions): Promise<CopyResult> {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  private async _copy(\n    options: CopyOptions,\n    doRename = false,\n  ): Promise<CopyResult> {\n    let { toDirectory } = options;\n    const { to, from, directory: fromDirectory } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return {\n        uri: toPath,\n      };\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory,\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory,\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory,\n    });\n\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path: string, ctime: number, mtime: number) => {\n      const fullPath: string = this.getPath(toDirectory, path);\n      const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file': {\n        // Read the file\n        const file = await this.readFile({\n          path: from,\n          directory: fromDirectory,\n        });\n\n        // Optionally remove the file\n        if (doRename) {\n          await this.deleteFile({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n\n        let encoding;\n        if (!(file.data instanceof Blob) && !this.isBase64String(file.data)) {\n          encoding = Encoding.UTF8;\n        }\n\n        // Write the file to the new location\n        const writeResult = await this.writeFile({\n          path: to,\n          directory: toDirectory,\n          data: file.data,\n          encoding: encoding,\n        });\n\n        // Copy the mtime/ctime of a renamed file\n        if (doRename) {\n          await updateTime(to, ctime, fromObj.mtime);\n        }\n\n        // Resolve promise\n        return writeResult;\n      }\n      case 'directory': {\n        if (toObj) {\n          throw Error('Cannot move a directory over an existing object');\n        }\n\n        try {\n          // Create the to directory\n          await this.mkdir({\n            path: to,\n            directory: toDirectory,\n            recursive: false,\n          });\n\n          // Copy the mtime/ctime of a renamed directory\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n        } catch (e) {\n          // ignore\n        }\n\n        // Iterate over the contents of the from location\n        const contents = (\n          await this.readdir({\n            path: from,\n            directory: fromDirectory,\n          })\n        ).files;\n\n        for (const filename of contents) {\n          // Move item from the from directory to the to directory\n          await this._copy(\n            {\n              from: `${from}/${filename.name}`,\n              to: `${to}/${filename.name}`,\n              directory: fromDirectory,\n              toDirectory,\n            },\n            doRename,\n          );\n        }\n\n        // Optionally remove the original from directory\n        if (doRename) {\n          await this.rmdir({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n      }\n    }\n    return {\n      uri: toPath,\n    };\n  }\n\n  /**\n   * Function that performs a http request to a server and downloads the file to the specified destination\n   *\n   * @param options the options for the download operation\n   * @returns a promise that resolves with the download file result\n   */\n  public downloadFile = async (\n    options: DownloadFileOptions,\n  ): Promise<DownloadFileResult> => {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const response = await fetch(options.url, requestInit);\n    let blob: Blob;\n\n    if (!options.progress) blob = await response.blob();\n    else if (!response?.body) blob = new Blob();\n    else {\n      const reader = response.body.getReader();\n\n      let bytes = 0;\n      const chunks: (Uint8Array | undefined)[] = [];\n\n      const contentType: string | null = response.headers.get('content-type');\n      const contentLength: number = parseInt(\n        response.headers.get('content-length') || '0',\n        10,\n      );\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) break;\n\n        chunks.push(value);\n        bytes += value?.length || 0;\n\n        const status: ProgressStatus = {\n          url: options.url,\n          bytes,\n          contentLength,\n        };\n\n        this.notifyListeners('progress', status);\n      }\n\n      const allChunks = new Uint8Array(bytes);\n      let position = 0;\n      for (const chunk of chunks) {\n        if (typeof chunk === 'undefined') continue;\n\n        allChunks.set(chunk, position);\n        position += chunk.length;\n      }\n\n      blob = new Blob([allChunks.buffer], { type: contentType || undefined });\n    }\n\n    const result = await this.writeFile({\n      path: options.path,\n      directory: options.directory ?? undefined,\n      recursive: options.recursive ?? false,\n      data: blob,\n    });\n\n    return { path: result.uri, blob };\n  };\n\n  private isBase64String(str: string): boolean {\n    try {\n      return btoa(atob(str)) == str;\n    } catch (err) {\n      return false;\n    }\n  }\n}\n\ninterface EntryObj {\n  path: string;\n  folder: string;\n  type: 'directory' | 'file';\n  size: number;\n  ctime: number;\n  mtime: number;\n  uri?: string;\n  content?: string | Blob;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}