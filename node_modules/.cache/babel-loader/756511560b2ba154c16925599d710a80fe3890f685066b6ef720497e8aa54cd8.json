{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableMap, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n  constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {\n    super();\n    this._languageService = _languageService;\n    this._languageConfigurationService = _languageConfigurationService;\n    this._textModel = _textModel;\n    this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n    this._languageId = _languageId;\n    this._attachedViews = _attachedViews;\n    this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n    this._onDidChangeLanguage = this._register(new Emitter());\n    this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n    this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n    this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    this._register(this.grammarTokens.onDidChangeTokens(e => {\n      this._emitModelTokensChangedEvent(e);\n    }));\n    this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState(e => {\n      this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n    }));\n  }\n  handleLanguageConfigurationServiceChange(e) {\n    if (e.affects(this._languageId)) {\n      this._onDidChangeLanguageConfiguration.fire({});\n    }\n  }\n  handleDidChangeContent(e) {\n    if (e.isFlush) {\n      this._semanticTokens.flush();\n    } else if (!e.isEolChange) {\n      // We don't have to do anything on an EOL change\n      for (const c of e.changes) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n        this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n      }\n    }\n    this.grammarTokens.handleDidChangeContent(e);\n  }\n  handleDidChangeAttached() {\n    this.grammarTokens.handleDidChangeAttached();\n  }\n  /**\n   * Includes grammar and semantic tokens.\n   */\n  getLineTokens(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);\n    return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n  }\n  _emitModelTokensChangedEvent(e) {\n    if (!this._textModel._isDisposing()) {\n      this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n      this._onDidChangeTokens.fire(e);\n    }\n  }\n  // #region Grammar Tokens\n  validateLineNumber(lineNumber) {\n    if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n      throw new BugIndicatingError('Illegal value for lineNumber');\n    }\n  }\n  get hasTokens() {\n    return this.grammarTokens.hasTokens;\n  }\n  resetTokenization() {\n    this.grammarTokens.resetTokenization();\n  }\n  get backgroundTokenizationState() {\n    return this.grammarTokens.backgroundTokenizationState;\n  }\n  forceTokenization(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    this.grammarTokens.forceTokenization(lineNumber);\n  }\n  hasAccurateTokensForLine(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    return this.grammarTokens.hasAccurateTokensForLine(lineNumber);\n  }\n  isCheapToTokenize(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    return this.grammarTokens.isCheapToTokenize(lineNumber);\n  }\n  tokenizeIfCheap(lineNumber) {\n    this.validateLineNumber(lineNumber);\n    this.grammarTokens.tokenizeIfCheap(lineNumber);\n  }\n  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n    return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n  }\n  tokenizeLineWithEdit(position, length, newText) {\n    return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);\n  }\n  // #endregion\n  // #region Semantic Tokens\n  setSemanticTokens(tokens, isComplete) {\n    this._semanticTokens.set(tokens, isComplete);\n    this._emitModelTokensChangedEvent({\n      semanticTokensApplied: tokens !== null,\n      ranges: [{\n        fromLineNumber: 1,\n        toLineNumber: this._textModel.getLineCount()\n      }]\n    });\n  }\n  hasCompleteSemanticTokens() {\n    return this._semanticTokens.isComplete();\n  }\n  hasSomeSemanticTokens() {\n    return !this._semanticTokens.isEmpty();\n  }\n  setPartialSemanticTokens(range, tokens) {\n    if (this.hasCompleteSemanticTokens()) {\n      return;\n    }\n    const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n    this._emitModelTokensChangedEvent({\n      semanticTokensApplied: true,\n      ranges: [{\n        fromLineNumber: changedRange.startLineNumber,\n        toLineNumber: changedRange.endLineNumber\n      }]\n    });\n  }\n  // #endregion\n  // #region Utility Methods\n  getWordAtPosition(_position) {\n    this.assertNotDisposed();\n    const position = this._textModel.validatePosition(_position);\n    const lineContent = this._textModel.getLineContent(position.lineNumber);\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    // (1). First try checking right biased word\n    const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n    const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n    // Make sure the result touches the original passed in position\n    if (rightBiasedWord && rightBiasedWord.startColumn <= _position.column && _position.column <= rightBiasedWord.endColumn) {\n      return rightBiasedWord;\n    }\n    // (2). Else, if we were at a language boundary, check the left biased word\n    if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n      // edge case, where `position` sits between two tokens belonging to two different languages\n      const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n      const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n      // Make sure the result touches the original passed in position\n      if (leftBiasedWord && leftBiasedWord.startColumn <= _position.column && _position.column <= leftBiasedWord.endColumn) {\n        return leftBiasedWord;\n      }\n    }\n    return null;\n  }\n  getLanguageConfiguration(languageId) {\n    return this._languageConfigurationService.getLanguageConfiguration(languageId);\n  }\n  static _findLanguageBoundaries(lineTokens, tokenIndex) {\n    const languageId = lineTokens.getLanguageId(tokenIndex);\n    // go left until a different language is hit\n    let startOffset = 0;\n    for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n      startOffset = lineTokens.getStartOffset(i);\n    }\n    // go right until a different language is hit\n    let endOffset = lineTokens.getLineContent().length;\n    for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n      endOffset = lineTokens.getEndOffset(i);\n    }\n    return [startOffset, endOffset];\n  }\n  getWordUntilPosition(position) {\n    const wordAtPosition = this.getWordAtPosition(position);\n    if (!wordAtPosition) {\n      return {\n        word: '',\n        startColumn: position.column,\n        endColumn: position.column\n      };\n    }\n    return {\n      word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n      startColumn: wordAtPosition.startColumn,\n      endColumn: position.column\n    };\n  }\n  // #endregion\n  // #region Language Id handling\n  getLanguageId() {\n    return this._languageId;\n  }\n  getLanguageIdAtPosition(lineNumber, column) {\n    const position = this._textModel.validatePosition(new Position(lineNumber, column));\n    const lineTokens = this.getLineTokens(position.lineNumber);\n    return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n  }\n  setLanguageId(languageId, source = 'api') {\n    if (this._languageId === languageId) {\n      // There's nothing to do\n      return;\n    }\n    const e = {\n      oldLanguage: this._languageId,\n      newLanguage: languageId,\n      source\n    };\n    this._languageId = languageId;\n    this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n    this.grammarTokens.resetTokenization();\n    this._onDidChangeLanguage.fire(e);\n    this._onDidChangeLanguageConfiguration.fire({});\n  }\n}\nclass GrammarTokens extends Disposable {\n  get backgroundTokenizationState() {\n    return this._backgroundTokenizationState;\n  }\n  constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {\n    super();\n    this._languageIdCodec = _languageIdCodec;\n    this._textModel = _textModel;\n    this.getLanguageId = getLanguageId;\n    this._tokenizer = null;\n    this._defaultBackgroundTokenizer = null;\n    this._backgroundTokenizer = this._register(new MutableDisposable());\n    this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n    this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n    this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n    this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n    /** @internal, should not be exposed by the text model! */\n    this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n    this._onDidChangeTokens = this._register(new Emitter());\n    /** @internal, should not be exposed by the text model! */\n    this.onDidChangeTokens = this._onDidChangeTokens.event;\n    this._attachedViewStates = this._register(new DisposableMap());\n    this._register(TokenizationRegistry.onDidChange(e => {\n      const languageId = this.getLanguageId();\n      if (e.changedLanguages.indexOf(languageId) === -1) {\n        return;\n      }\n      this.resetTokenization();\n    }));\n    this.resetTokenization();\n    this._register(attachedViews.onDidChangeVisibleRanges(({\n      view,\n      state\n    }) => {\n      if (state) {\n        let existing = this._attachedViewStates.get(view);\n        if (!existing) {\n          existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n          this._attachedViewStates.set(view, existing);\n        }\n        existing.handleStateChange(state);\n      } else {\n        this._attachedViewStates.deleteAndDispose(view);\n      }\n    }));\n  }\n  resetTokenization(fireTokenChangeEvent = true) {\n    this._tokens.flush();\n    this._debugBackgroundTokens?.flush();\n    if (this._debugBackgroundStates) {\n      this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n    }\n    if (fireTokenChangeEvent) {\n      this._onDidChangeTokens.fire({\n        semanticTokensApplied: false,\n        ranges: [{\n          fromLineNumber: 1,\n          toLineNumber: this._textModel.getLineCount()\n        }]\n      });\n    }\n    const initializeTokenization = () => {\n      if (this._textModel.isTooLargeForTokenization()) {\n        return [null, null];\n      }\n      const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n      if (!tokenizationSupport) {\n        return [null, null];\n      }\n      let initialState;\n      try {\n        initialState = tokenizationSupport.getInitialState();\n      } catch (e) {\n        onUnexpectedError(e);\n        return [null, null];\n      }\n      return [tokenizationSupport, initialState];\n    };\n    const [tokenizationSupport, initialState] = initializeTokenization();\n    if (tokenizationSupport && initialState) {\n      this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n    } else {\n      this._tokenizer = null;\n    }\n    this._backgroundTokenizer.clear();\n    this._defaultBackgroundTokenizer = null;\n    if (this._tokenizer) {\n      const b = {\n        setTokens: tokens => {\n          this.setTokens(tokens);\n        },\n        backgroundTokenizationFinished: () => {\n          if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // We already did a full tokenization and don't go back to progressing.\n            return;\n          }\n          const newState = 2 /* BackgroundTokenizationState.Completed */;\n          this._backgroundTokenizationState = newState;\n          this._onDidChangeBackgroundTokenizationState.fire();\n        },\n        setEndState: (lineNumber, state) => {\n          if (!this._tokenizer) {\n            return;\n          }\n          const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n          // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n          if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n            this._tokenizer?.store.setEndState(lineNumber, state);\n          }\n        }\n      };\n      if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n        this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n      }\n      if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n        this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new DefaultBackgroundTokenizer(this._tokenizer, b);\n        this._defaultBackgroundTokenizer.handleChanges();\n      }\n      if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n        this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        this._debugBackgroundTokenizer.clear();\n        this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n          setTokens: tokens => {\n            this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n          },\n          backgroundTokenizationFinished() {\n            // NO OP\n          },\n          setEndState: (lineNumber, state) => {\n            this._debugBackgroundStates?.setEndState(lineNumber, state);\n          }\n        });\n      } else {\n        this._debugBackgroundTokens = undefined;\n        this._debugBackgroundStates = undefined;\n        this._debugBackgroundTokenizer.value = undefined;\n      }\n    }\n    this.refreshAllVisibleLineTokens();\n  }\n  handleDidChangeAttached() {\n    this._defaultBackgroundTokenizer?.handleChanges();\n  }\n  handleDidChangeContent(e) {\n    if (e.isFlush) {\n      // Don't fire the event, as the view might not have got the text change event yet\n      this.resetTokenization(false);\n    } else if (!e.isEolChange) {\n      // We don't have to do anything on an EOL change\n      for (const c of e.changes) {\n        const [eolCount, firstLineLength] = countEOL(c.text);\n        this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n        this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n      }\n      this._debugBackgroundStates?.acceptChanges(e.changes);\n      if (this._tokenizer) {\n        this._tokenizer.store.acceptChanges(e.changes);\n      }\n      this._defaultBackgroundTokenizer?.handleChanges();\n    }\n  }\n  setTokens(tokens) {\n    const {\n      changes\n    } = this._tokens.setMultilineTokens(tokens, this._textModel);\n    if (changes.length > 0) {\n      this._onDidChangeTokens.fire({\n        semanticTokensApplied: false,\n        ranges: changes\n      });\n    }\n    return {\n      changes: changes\n    };\n  }\n  refreshAllVisibleLineTokens() {\n    const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n    this.refreshRanges(ranges);\n  }\n  refreshRanges(ranges) {\n    for (const range of ranges) {\n      this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n    }\n  }\n  refreshRange(startLineNumber, endLineNumber) {\n    if (!this._tokenizer) {\n      return;\n    }\n    startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n    endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n    const builder = new ContiguousMultilineTokensBuilder();\n    const {\n      heuristicTokens\n    } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n    const changedTokens = this.setTokens(builder.finalize());\n    if (heuristicTokens) {\n      // We overrode tokens with heuristically computed ones.\n      // Because old states might get reused (thus stopping invalidation),\n      // we have to explicitly request the tokens for the changed ranges again.\n      for (const c of changedTokens.changes) {\n        this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n      }\n    }\n    this._defaultBackgroundTokenizer?.checkFinished();\n  }\n  forceTokenization(lineNumber) {\n    const builder = new ContiguousMultilineTokensBuilder();\n    this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n    this.setTokens(builder.finalize());\n    this._defaultBackgroundTokenizer?.checkFinished();\n  }\n  hasAccurateTokensForLine(lineNumber) {\n    if (!this._tokenizer) {\n      return true;\n    }\n    return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n  }\n  isCheapToTokenize(lineNumber) {\n    if (!this._tokenizer) {\n      return true;\n    }\n    return this._tokenizer.isCheapToTokenize(lineNumber);\n  }\n  tokenizeIfCheap(lineNumber) {\n    if (this.isCheapToTokenize(lineNumber)) {\n      this.forceTokenization(lineNumber);\n    }\n  }\n  getLineTokens(lineNumber) {\n    const lineText = this._textModel.getLineContent(lineNumber);\n    const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n    if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n      if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n        const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n          this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n        }\n      }\n    }\n    return result;\n  }\n  getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n    if (!this._tokenizer) {\n      return 0 /* StandardTokenType.Other */;\n    }\n    const position = this._textModel.validatePosition(new Position(lineNumber, column));\n    this.forceTokenization(position.lineNumber);\n    return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n  }\n  tokenizeLineWithEdit(position, length, newText) {\n    if (!this._tokenizer) {\n      return null;\n    }\n    const validatedPosition = this._textModel.validatePosition(position);\n    this.forceTokenization(validatedPosition.lineNumber);\n    return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n  }\n  get hasTokens() {\n    return this._tokens.hasTokens;\n  }\n}\nclass AttachedViewHandler extends Disposable {\n  get lineRanges() {\n    return this._lineRanges;\n  }\n  constructor(_refreshTokens) {\n    super();\n    this._refreshTokens = _refreshTokens;\n    this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n    this._computedLineRanges = [];\n    this._lineRanges = [];\n  }\n  update() {\n    if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n      return;\n    }\n    this._computedLineRanges = this._lineRanges;\n    this._refreshTokens();\n  }\n  handleStateChange(state) {\n    this._lineRanges = state.visibleLineRanges;\n    if (state.stabilized) {\n      this.runner.cancel();\n      this.update();\n    } else {\n      this.runner.schedule();\n    }\n  }\n}","map":{"version":3,"names":["equals","RunOnceScheduler","BugIndicatingError","onUnexpectedError","Emitter","Disposable","DisposableMap","MutableDisposable","countEOL","LineRange","Position","getWordAtText","TokenizationRegistry","TextModelPart","DefaultBackgroundTokenizer","TokenizerWithStateStoreAndTextModel","TrackingTokenizationStateStore","ContiguousMultilineTokensBuilder","ContiguousTokensStore","SparseTokensStore","TokenizationTextModelPart","constructor","_languageService","_languageConfigurationService","_textModel","_bracketPairsTextModelPart","_languageId","_attachedViews","_semanticTokens","languageIdCodec","_onDidChangeLanguage","_register","onDidChangeLanguage","event","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_onDidChangeTokens","onDidChangeTokens","grammarTokens","GrammarTokens","e","_emitModelTokensChangedEvent","onDidChangeBackgroundTokenizationState","handleDidChangeBackgroundTokenizationState","handleLanguageConfigurationServiceChange","affects","fire","handleDidChangeContent","isFlush","flush","isEolChange","c","changes","eolCount","firstLineLength","lastLineLength","text","acceptEdit","range","length","charCodeAt","handleDidChangeAttached","getLineTokens","lineNumber","validateLineNumber","syntacticTokens","addSparseTokens","_isDisposing","handleDidChangeTokens","getLineCount","hasTokens","resetTokenization","backgroundTokenizationState","forceTokenization","hasAccurateTokensForLine","isCheapToTokenize","tokenizeIfCheap","getTokenTypeIfInsertingCharacter","column","character","tokenizeLineWithEdit","position","newText","setSemanticTokens","tokens","isComplete","set","semanticTokensApplied","ranges","fromLineNumber","toLineNumber","hasCompleteSemanticTokens","hasSomeSemanticTokens","isEmpty","setPartialSemanticTokens","changedRange","validateRange","setPartial","startLineNumber","endLineNumber","getWordAtPosition","_position","assertNotDisposed","validatePosition","lineContent","getLineContent","lineTokens","tokenIndex","findTokenIndexAtOffset","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getLanguageConfiguration","getLanguageId","getWordDefinition","substring","startColumn","endColumn","lbStartOffset","lbEndOffset","leftBiasedWord","languageId","startOffset","i","getStartOffset","endOffset","tokenCount","getCount","getEndOffset","getWordUntilPosition","wordAtPosition","word","substr","getLanguageIdAtPosition","setLanguageId","source","oldLanguage","newLanguage","handleDidChangeLanguage","_backgroundTokenizationState","_languageIdCodec","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_tokens","_debugBackgroundTokenizer","_onDidChangeBackgroundTokenizationState","_attachedViewStates","onDidChange","changedLanguages","indexOf","onDidChangeVisibleRanges","view","state","existing","get","AttachedViewHandler","refreshRanges","lineRanges","handleStateChange","deleteAndDispose","fireTokenChangeEvent","_debugBackgroundTokens","_debugBackgroundStates","initializeTokenization","isTooLargeForTokenization","tokenizationSupport","initialState","getInitialState","clear","b","setTokens","backgroundTokenizationFinished","newState","setEndState","firstInvalidEndStateLineNumber","store","getFirstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","value","handleChanges","setMultilineTokens","undefined","refreshAllVisibleLineTokens","acceptChanges","joinMany","map","_","s","refreshRange","endLineNumberExclusive","Math","max","min","builder","heuristicTokens","tokenizeHeuristically","changedTokens","finalize","requestTokens","checkFinished","updateTokensUntilLine","lineText","result","getTokens","getFirstInvalidEndStateLineNumberOrMax","backgroundResult","reportMismatchingTokens","validatedPosition","_lineRanges","_refreshTokens","runner","update","_computedLineRanges","a","visibleLineRanges","stabilized","cancel","schedule"],"sources":["C:/Users/ruzhe/CODEHUB-PH/GAMES/code-master/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableMap, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nexport class TokenizationTextModelPart extends TextModelPart {\n    constructor(_languageService, _languageConfigurationService, _textModel, _bracketPairsTextModelPart, _languageId, _attachedViews) {\n        super();\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this.grammarTokens = this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n        this._register(this.grammarTokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._register(this.grammarTokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this.grammarTokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this.grammarTokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this.grammarTokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this.grammarTokens.hasTokens;\n    }\n    resetTokenization() {\n        this.grammarTokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this.grammarTokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this.grammarTokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this.grammarTokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this.grammarTokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this.grammarTokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this.grammarTokens.resetTokenization();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n}\nclass GrammarTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId, attachedViews) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\nclass AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}