{"ast":null,"code":"var _CharWidthReader;\nimport \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nclass UnknownHitTestResult {\n  constructor(hitTarget = null) {\n    this.hitTarget = hitTarget;\n    this.type = 0 /* HitTestResultType.Unknown */;\n  }\n}\nclass ContentHitTestResult {\n  get hitTarget() {\n    return this.spanNode;\n  }\n  constructor(position, spanNode, injectedText) {\n    this.position = position;\n    this.spanNode = spanNode;\n    this.injectedText = injectedText;\n    this.type = 1 /* HitTestResultType.Content */;\n  }\n}\nvar HitTestResult;\n(function (HitTestResult) {\n  function createFromDOMInfo(ctx, spanNode, offset) {\n    const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n    if (position) {\n      return new ContentHitTestResult(position, spanNode, null);\n    }\n    return new UnknownHitTestResult(spanNode);\n  }\n  HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport class PointerHandlerLastRenderData {\n  constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n    this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n    this.lastTextareaPosition = lastTextareaPosition;\n  }\n}\nexport class MouseTarget {\n  static _deduceRage(position, range = null) {\n    if (!range && position) {\n      return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n    }\n    return range ?? null;\n  }\n  static createUnknown(element, mouseColumn, position) {\n    return {\n      type: 0 /* MouseTargetType.UNKNOWN */,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position)\n    };\n  }\n  static createTextarea(element, mouseColumn) {\n    return {\n      type: 1 /* MouseTargetType.TEXTAREA */,\n      element,\n      mouseColumn,\n      position: null,\n      range: null\n    };\n  }\n  static createMargin(type, element, mouseColumn, position, range, detail) {\n    return {\n      type,\n      element,\n      mouseColumn,\n      position,\n      range,\n      detail\n    };\n  }\n  static createViewZone(type, element, mouseColumn, position, detail) {\n    return {\n      type,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position),\n      detail\n    };\n  }\n  static createContentText(element, mouseColumn, position, range, detail) {\n    return {\n      type: 6 /* MouseTargetType.CONTENT_TEXT */,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position, range),\n      detail\n    };\n  }\n  static createContentEmpty(element, mouseColumn, position, detail) {\n    return {\n      type: 7 /* MouseTargetType.CONTENT_EMPTY */,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position),\n      detail\n    };\n  }\n  static createContentWidget(element, mouseColumn, detail) {\n    return {\n      type: 9 /* MouseTargetType.CONTENT_WIDGET */,\n      element,\n      mouseColumn,\n      position: null,\n      range: null,\n      detail\n    };\n  }\n  static createScrollbar(element, mouseColumn, position) {\n    return {\n      type: 11 /* MouseTargetType.SCROLLBAR */,\n      element,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position)\n    };\n  }\n  static createOverlayWidget(element, mouseColumn, detail) {\n    return {\n      type: 12 /* MouseTargetType.OVERLAY_WIDGET */,\n      element,\n      mouseColumn,\n      position: null,\n      range: null,\n      detail\n    };\n  }\n  static createOutsideEditor(mouseColumn, position, outsidePosition, outsideDistance) {\n    return {\n      type: 13 /* MouseTargetType.OUTSIDE_EDITOR */,\n      element: null,\n      mouseColumn,\n      position,\n      range: this._deduceRage(position),\n      outsidePosition,\n      outsideDistance\n    };\n  }\n  static _typeToString(type) {\n    if (type === 1 /* MouseTargetType.TEXTAREA */) {\n      return 'TEXTAREA';\n    }\n    if (type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */) {\n      return 'GUTTER_GLYPH_MARGIN';\n    }\n    if (type === 3 /* MouseTargetType.GUTTER_LINE_NUMBERS */) {\n      return 'GUTTER_LINE_NUMBERS';\n    }\n    if (type === 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n      return 'GUTTER_LINE_DECORATIONS';\n    }\n    if (type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n      return 'GUTTER_VIEW_ZONE';\n    }\n    if (type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n      return 'CONTENT_TEXT';\n    }\n    if (type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n      return 'CONTENT_EMPTY';\n    }\n    if (type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {\n      return 'CONTENT_VIEW_ZONE';\n    }\n    if (type === 9 /* MouseTargetType.CONTENT_WIDGET */) {\n      return 'CONTENT_WIDGET';\n    }\n    if (type === 10 /* MouseTargetType.OVERVIEW_RULER */) {\n      return 'OVERVIEW_RULER';\n    }\n    if (type === 11 /* MouseTargetType.SCROLLBAR */) {\n      return 'SCROLLBAR';\n    }\n    if (type === 12 /* MouseTargetType.OVERLAY_WIDGET */) {\n      return 'OVERLAY_WIDGET';\n    }\n    return 'UNKNOWN';\n  }\n  static toString(target) {\n    return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n  }\n}\nclass ElementPath {\n  static isTextArea(path) {\n    return path.length === 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 7 /* PartFingerprint.TextArea */;\n  }\n  static isChildOfViewLines(path) {\n    return path.length >= 4 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[3] === 8 /* PartFingerprint.ViewLines */;\n  }\n  static isStrictChildOfViewLines(path) {\n    return path.length > 4 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[3] === 8 /* PartFingerprint.ViewLines */;\n  }\n  static isChildOfScrollableElement(path) {\n    return path.length >= 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 6 /* PartFingerprint.ScrollableElement */;\n  }\n  static isChildOfMinimap(path) {\n    return path.length >= 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 9 /* PartFingerprint.Minimap */;\n  }\n  static isChildOfContentWidgets(path) {\n    return path.length >= 4 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[3] === 1 /* PartFingerprint.ContentWidgets */;\n  }\n  static isChildOfOverflowGuard(path) {\n    return path.length >= 1 && path[0] === 3 /* PartFingerprint.OverflowGuard */;\n  }\n  static isChildOfOverflowingContentWidgets(path) {\n    return path.length >= 1 && path[0] === 2 /* PartFingerprint.OverflowingContentWidgets */;\n  }\n  static isChildOfOverlayWidgets(path) {\n    return path.length >= 2 && path[0] === 3 /* PartFingerprint.OverflowGuard */ && path[1] === 4 /* PartFingerprint.OverlayWidgets */;\n  }\n  static isChildOfOverflowingOverlayWidgets(path) {\n    return path.length >= 1 && path[0] === 5 /* PartFingerprint.OverflowingOverlayWidgets */;\n  }\n}\nexport class HitTestContext {\n  constructor(context, viewHelper, lastRenderData) {\n    this.viewModel = context.viewModel;\n    const options = context.configuration.options;\n    this.layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n    this.viewDomNode = viewHelper.viewDomNode;\n    this.overflowWidgetsDomNode = viewHelper.overflowWidgetsDomNode ?? null;\n    this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n    this.stickyTabStops = options.get(117 /* EditorOption.stickyTabStops */);\n    this.typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n    this.lastRenderData = lastRenderData;\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n  getZoneAtCoord(mouseVerticalOffset) {\n    return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n  }\n  static getZoneAtCoord(context, mouseVerticalOffset) {\n    // The target is either a view zone or the empty space after the last view-line\n    const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n    if (viewZoneWhitespace) {\n      const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n      const lineCount = context.viewModel.getLineCount();\n      let positionBefore = null;\n      let position;\n      let positionAfter = null;\n      if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n        // There are more lines after this view zone\n        positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n      }\n      if (viewZoneWhitespace.afterLineNumber > 0) {\n        // There are more lines above this view zone\n        positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n      }\n      if (positionAfter === null) {\n        position = positionBefore;\n      } else if (positionBefore === null) {\n        position = positionAfter;\n      } else if (mouseVerticalOffset < viewZoneMiddle) {\n        position = positionBefore;\n      } else {\n        position = positionAfter;\n      }\n      return {\n        viewZoneId: viewZoneWhitespace.id,\n        afterLineNumber: viewZoneWhitespace.afterLineNumber,\n        positionBefore: positionBefore,\n        positionAfter: positionAfter,\n        position: position\n      };\n    }\n    return null;\n  }\n  getFullLineRangeAtCoord(mouseVerticalOffset) {\n    if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n      // Below the last line\n      const lineNumber = this._context.viewModel.getLineCount();\n      const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n      return {\n        range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n        isAfterLines: true\n      };\n    }\n    const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n    return {\n      range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n      isAfterLines: false\n    };\n  }\n  getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n    return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n  }\n  isAfterLines(mouseVerticalOffset) {\n    return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n  }\n  isInTopPadding(mouseVerticalOffset) {\n    return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n  }\n  isInBottomPadding(mouseVerticalOffset) {\n    return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n  }\n  getVerticalOffsetForLineNumber(lineNumber) {\n    return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n  }\n  findAttribute(element, attr) {\n    return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n  }\n  static _findAttribute(element, attr, stopAt) {\n    while (element && element !== element.ownerDocument.body) {\n      if (element.hasAttribute && element.hasAttribute(attr)) {\n        return element.getAttribute(attr);\n      }\n      if (element === stopAt) {\n        return null;\n      }\n      element = element.parentNode;\n    }\n    return null;\n  }\n  getLineWidth(lineNumber) {\n    return this._viewHelper.getLineWidth(lineNumber);\n  }\n  visibleRangeForPosition(lineNumber, column) {\n    return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n  }\n  getPositionFromDOMInfo(spanNode, offset) {\n    return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n  }\n  getCurrentScrollTop() {\n    return this._context.viewLayout.getCurrentScrollTop();\n  }\n  getCurrentScrollLeft() {\n    return this._context.viewLayout.getCurrentScrollLeft();\n  }\n}\nclass BareHitTestRequest {\n  constructor(ctx, editorPos, pos, relativePos) {\n    this.editorPos = editorPos;\n    this.pos = pos;\n    this.relativePos = relativePos;\n    this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n    this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n    this.isInMarginArea = this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft;\n    this.isInContentArea = !this.isInMarginArea;\n    this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n  }\n}\nclass HitTestRequest extends BareHitTestRequest {\n  get target() {\n    if (this._useHitTestTarget) {\n      return this.hitTestResult.value.hitTarget;\n    }\n    return this._eventTarget;\n  }\n  get targetPath() {\n    if (this._targetPathCacheElement !== this.target && this._targetElement) {\n      this._targetPathCacheElement = this.target;\n      this._targetPathCacheValue = PartFingerprints.collect(this.target, this._targetElement);\n    }\n    return this._targetPathCacheValue;\n  }\n  constructor(ctx, editorPos, pos, relativePos, eventTarget, targetElement = null) {\n    super(ctx, editorPos, pos, relativePos);\n    this.hitTestResult = new Lazy(() => MouseTargetFactory.doHitTest(this._ctx, this));\n    this._targetPathCacheElement = null;\n    this._targetPathCacheValue = new Uint8Array(0);\n    this._targetElement = null;\n    this._ctx = ctx;\n    this._eventTarget = eventTarget;\n    this._targetElement = targetElement;\n    // If no event target is passed in, we will use the hit test target\n    const hasEventTarget = Boolean(this._eventTarget);\n    this._useHitTestTarget = !hasEventTarget;\n  }\n  toString() {\n    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n  }\n  get wouldBenefitFromHitTestTargetSwitch() {\n    return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;\n  }\n  switchToHitTestTarget() {\n    this._useHitTestTarget = true;\n  }\n  _getMouseColumn(position = null) {\n    if (position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber)) {\n      // Most likely, the line contains foreign decorations...\n      return CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1;\n    }\n    return this.mouseColumn;\n  }\n  fulfillUnknown(position = null) {\n    return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n  }\n  fulfillTextarea() {\n    return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n  }\n  fulfillMargin(type, position, range, detail) {\n    return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n  }\n  fulfillViewZone(type, position, detail) {\n    return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n  }\n  fulfillContentText(position, range, detail) {\n    return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n  }\n  fulfillContentEmpty(position, detail) {\n    return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n  }\n  fulfillContentWidget(detail) {\n    return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n  }\n  fulfillScrollbar(position) {\n    return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n  }\n  fulfillOverlayWidget(detail) {\n    return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n  }\n}\nconst EMPTY_CONTENT_AFTER_LINES = {\n  isAfterLines: true\n};\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n  return {\n    isAfterLines: false,\n    horizontalDistanceToText: horizontalDistanceToText\n  };\n}\nexport class MouseTargetFactory {\n  constructor(context, viewHelper) {\n    this._context = context;\n    this._viewHelper = viewHelper;\n  }\n  mouseTargetIsWidget(e) {\n    const t = e.target;\n    const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n    // Is it a content widget?\n    if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n      return true;\n    }\n    // Is it an overlay widget?\n    if (ElementPath.isChildOfOverlayWidgets(path) || ElementPath.isChildOfOverflowingOverlayWidgets(path)) {\n      return true;\n    }\n    return false;\n  }\n  createMouseTargetForView(lastRenderData, editorPos, pos, relativePos, target) {\n    const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n    const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target, ctx.viewDomNode);\n    try {\n      const r = MouseTargetFactory._createMouseTarget(ctx, request);\n      if (r.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n        // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n        if (ctx.stickyTabStops && r.position !== null) {\n          const position = MouseTargetFactory._snapToSoftTabBoundary(r.position, ctx.viewModel);\n          const range = EditorRange.fromPositions(position, position).plusRange(r.range);\n          return request.fulfillContentText(position, range, r.detail);\n        }\n      }\n      // console.log(MouseTarget.toString(r));\n      return r;\n    } catch (err) {\n      // console.log(err);\n      return request.fulfillUnknown();\n    }\n  }\n  createMouseTargetForOverflowWidgetsDomNode(lastRenderData, editorPos, pos, relativePos, target) {\n    const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n    const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target, ctx.overflowWidgetsDomNode);\n    try {\n      return MouseTargetFactory._createMouseTarget(ctx, request);\n    } catch (err) {\n      return request.fulfillUnknown();\n    }\n  }\n  static _createMouseTarget(ctx, request) {\n    // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n    if (request.target === null) {\n      // No target\n      return request.fulfillUnknown();\n    }\n    // we know for a fact that request.target is not null\n    const resolvedRequest = request;\n    let result = null;\n    if (!ElementPath.isChildOfOverflowGuard(request.targetPath) && !ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) && !ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n      // We only render dom nodes inside the overflow guard or in the overflowing content widgets\n      result = result || request.fulfillUnknown();\n    }\n    result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest);\n    result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n    return result || request.fulfillUnknown();\n  }\n  static _hitTestContentWidget(ctx, request) {\n    // Is it a content widget?\n    if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n      const widgetId = ctx.findAttribute(request.target, 'widgetId');\n      if (widgetId) {\n        return request.fulfillContentWidget(widgetId);\n      } else {\n        return request.fulfillUnknown();\n      }\n    }\n    return null;\n  }\n  static _hitTestOverlayWidget(ctx, request) {\n    // Is it an overlay widget?\n    if (ElementPath.isChildOfOverlayWidgets(request.targetPath) || ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n      const widgetId = ctx.findAttribute(request.target, 'widgetId');\n      if (widgetId) {\n        return request.fulfillOverlayWidget(widgetId);\n      } else {\n        return request.fulfillUnknown();\n      }\n    }\n    return null;\n  }\n  static _hitTestViewCursor(ctx, request) {\n    if (request.target) {\n      // Check if we've hit a painted cursor\n      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n      for (const d of lastViewCursorsRenderData) {\n        if (request.target === d.domNode) {\n          return request.fulfillContentText(d.position, null, {\n            mightBeForeignElement: false,\n            injectedText: null\n          });\n        }\n      }\n    }\n    if (request.isInContentArea) {\n      // Edge has a bug when hit-testing the exact position of a cursor,\n      // instead of returning the correct dom node, it returns the\n      // first or last rendered view line dom node, therefore help it out\n      // and first check if we are on top of a cursor\n      const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n      const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n      const mouseVerticalOffset = request.mouseVerticalOffset;\n      for (const d of lastViewCursorsRenderData) {\n        if (mouseContentHorizontalOffset < d.contentLeft) {\n          // mouse position is to the left of the cursor\n          continue;\n        }\n        if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n          // mouse position is to the right of the cursor\n          continue;\n        }\n        const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n        if (cursorVerticalOffset <= mouseVerticalOffset && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n          return request.fulfillContentText(d.position, null, {\n            mightBeForeignElement: false,\n            injectedText: null\n          });\n        }\n      }\n    }\n    return null;\n  }\n  static _hitTestViewZone(ctx, request) {\n    const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n    if (viewZoneData) {\n      const mouseTargetType = request.isInContentArea ? 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ : 5 /* MouseTargetType.GUTTER_VIEW_ZONE */;\n      return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n    }\n    return null;\n  }\n  static _hitTestTextArea(ctx, request) {\n    // Is it the textarea?\n    if (ElementPath.isTextArea(request.targetPath)) {\n      if (ctx.lastRenderData.lastTextareaPosition) {\n        return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, {\n          mightBeForeignElement: false,\n          injectedText: null\n        });\n      }\n      return request.fulfillTextarea();\n    }\n    return null;\n  }\n  static _hitTestMargin(ctx, request) {\n    if (request.isInMarginArea) {\n      const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n      const pos = res.range.getStartPosition();\n      let offset = Math.abs(request.relativePos.x);\n      const detail = {\n        isAfterLines: res.isAfterLines,\n        glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n        glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n        lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n        offsetX: offset\n      };\n      offset -= ctx.layoutInfo.glyphMarginLeft;\n      if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n        // On the glyph margin\n        const modelCoordinate = ctx.viewModel.coordinatesConverter.convertViewPositionToModelPosition(res.range.getStartPosition());\n        const lanes = ctx.viewModel.glyphLanes.getLanesAtLine(modelCoordinate.lineNumber);\n        detail.glyphMarginLane = lanes[Math.floor(offset / ctx.lineHeight)];\n        return request.fulfillMargin(2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n      }\n      offset -= ctx.layoutInfo.glyphMarginWidth;\n      if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n        // On the line numbers\n        return request.fulfillMargin(3 /* MouseTargetType.GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n      }\n      offset -= ctx.layoutInfo.lineNumbersWidth;\n      // On the line decorations\n      return request.fulfillMargin(4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n    }\n    return null;\n  }\n  static _hitTestViewLines(ctx, request) {\n    if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n      return null;\n    }\n    if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n      return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n    }\n    // Check if it is below any lines and any view zones\n    if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n      // This most likely indicates it happened after the last view-line\n      const lineCount = ctx.viewModel.getLineCount();\n      const maxLineColumn = ctx.viewModel.getLineMaxColumn(lineCount);\n      return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n    }\n    // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n    // See https://github.com/microsoft/vscode/issues/46942\n    if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n      const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      if (ctx.viewModel.getLineLength(lineNumber) === 0) {\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n        return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n      }\n      const lineWidth = ctx.getLineWidth(lineNumber);\n      if (request.mouseContentHorizontalOffset >= lineWidth) {\n        // TODO: This is wrong for RTL\n        const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n        const pos = new Position(lineNumber, ctx.viewModel.getLineMaxColumn(lineNumber));\n        return request.fulfillContentEmpty(pos, detail);\n      }\n    }\n    // Do the hit test (if not already done)\n    const hitTestResult = request.hitTestResult.value;\n    if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n      return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n    }\n    // We didn't hit content...\n    if (request.wouldBenefitFromHitTestTargetSwitch) {\n      // We actually hit something different... Give it one last change by trying again with this new target\n      request.switchToHitTestTarget();\n      return this._createMouseTarget(ctx, request);\n    }\n    // We have tried everything...\n    return request.fulfillUnknown();\n  }\n  static _hitTestMinimap(ctx, request) {\n    if (ElementPath.isChildOfMinimap(request.targetPath)) {\n      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n      return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n    }\n    return null;\n  }\n  static _hitTestScrollbarSlider(ctx, request) {\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      if (request.target && request.target.nodeType === 1) {\n        const className = request.target.className;\n        if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n          const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n          const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n          return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n      }\n    }\n    return null;\n  }\n  static _hitTestScrollbar(ctx, request) {\n    // Is it the overview ruler?\n    // Is it a child of the scrollable element?\n    if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n      const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n      const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n      return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n    }\n    return null;\n  }\n  getMouseColumn(relativePos) {\n    const options = this._context.configuration.options;\n    const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n    const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n    return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth);\n  }\n  static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n    if (mouseContentHorizontalOffset < 0) {\n      return 1;\n    }\n    const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n    return chars + 1;\n  }\n  static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n    const lineNumber = pos.lineNumber;\n    const column = pos.column;\n    const lineWidth = ctx.getLineWidth(lineNumber);\n    if (request.mouseContentHorizontalOffset > lineWidth) {\n      const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n      return request.fulfillContentEmpty(pos, detail);\n    }\n    const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n    if (!visibleRange) {\n      return request.fulfillUnknown(pos);\n    }\n    const columnHorizontalOffset = visibleRange.left;\n    if (Math.abs(request.mouseContentHorizontalOffset - columnHorizontalOffset) < 1) {\n      return request.fulfillContentText(pos, null, {\n        mightBeForeignElement: !!injectedText,\n        injectedText\n      });\n    }\n    const points = [];\n    points.push({\n      offset: visibleRange.left,\n      column: column\n    });\n    if (column > 1) {\n      const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n      if (visibleRange) {\n        points.push({\n          offset: visibleRange.left,\n          column: column - 1\n        });\n      }\n    }\n    const lineMaxColumn = ctx.viewModel.getLineMaxColumn(lineNumber);\n    if (column < lineMaxColumn) {\n      const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n      if (visibleRange) {\n        points.push({\n          offset: visibleRange.left,\n          column: column + 1\n        });\n      }\n    }\n    points.sort((a, b) => a.offset - b.offset);\n    const mouseCoordinates = request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode));\n    const spanNodeClientRect = spanNode.getBoundingClientRect();\n    const mouseIsOverSpanNode = spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right;\n    let rng = null;\n    for (let i = 1; i < points.length; i++) {\n      const prev = points[i - 1];\n      const curr = points[i];\n      if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n        rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n        // See https://github.com/microsoft/vscode/issues/152819\n        // Due to the use of zwj, the browser's hit test result is skewed towards the left\n        // Here we try to correct that if the mouse horizontal offset is closer to the right than the left\n        const prevDelta = Math.abs(prev.offset - request.mouseContentHorizontalOffset);\n        const nextDelta = Math.abs(curr.offset - request.mouseContentHorizontalOffset);\n        pos = prevDelta < nextDelta ? new Position(lineNumber, prev.column) : new Position(lineNumber, curr.column);\n        break;\n      }\n    }\n    return request.fulfillContentText(pos, rng, {\n      mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText,\n      injectedText\n    });\n  }\n  /**\n   * Most probably WebKit browsers and Edge\n   */\n  static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n    // In Chrome, especially on Linux it is possible to click between lines,\n    // so try to adjust the `hity` below so that it lands in the center of a line\n    const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n    const lineStartVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n    const lineEndVerticalOffset = lineStartVerticalOffset + ctx.lineHeight;\n    const isBelowLastLine = lineNumber === ctx.viewModel.getLineCount() && request.mouseVerticalOffset > lineEndVerticalOffset;\n    if (!isBelowLastLine) {\n      const lineCenteredVerticalOffset = Math.floor((lineStartVerticalOffset + lineEndVerticalOffset) / 2);\n      let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n      if (adjustedPageY <= request.editorPos.y) {\n        adjustedPageY = request.editorPos.y + 1;\n      }\n      if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n        adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n      }\n      const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n      const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n      if (r.type === 1 /* HitTestResultType.Content */) {\n        return r;\n      }\n    }\n    // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n    return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n  }\n  static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n    const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n    let range;\n    if (shadowRoot) {\n      if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n        range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n      } else {\n        range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n      }\n    } else {\n      range = ctx.viewDomNode.ownerDocument.caretRangeFromPoint(coords.clientX, coords.clientY);\n    }\n    if (!range || !range.startContainer) {\n      return new UnknownHitTestResult();\n    }\n    // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n    const startContainer = range.startContainer;\n    if (startContainer.nodeType === startContainer.TEXT_NODE) {\n      // startContainer is expected to be the token text\n      const parent1 = startContainer.parentNode; // expected to be the token span\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n      const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n      } else {\n        return new UnknownHitTestResult(startContainer.parentNode);\n      }\n    } else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n      // startContainer is expected to be the token span\n      const parent1 = startContainer.parentNode; // expected to be the view line container span\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n      if (parent2ClassName === ViewLine.CLASS_NAME) {\n        return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n      } else {\n        return new UnknownHitTestResult(startContainer);\n      }\n    }\n    return new UnknownHitTestResult();\n  }\n  /**\n   * Most probably Gecko\n   */\n  static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n    const hitResult = ctx.viewDomNode.ownerDocument.caretPositionFromPoint(coords.clientX, coords.clientY);\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n      // offsetNode is expected to be the token text\n      const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n      const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n      const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n      const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n      if (parent3ClassName === ViewLine.CLASS_NAME) {\n        return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n      } else {\n        return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n      }\n    }\n    // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n    // Some other times, it returns the `<span>` with the inline decoration\n    if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n      const parent1 = hitResult.offsetNode.parentNode;\n      const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n      const parent2 = parent1 ? parent1.parentNode : null;\n      const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n      if (parent1ClassName === ViewLine.CLASS_NAME) {\n        // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n        if (tokenSpan) {\n          return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n        }\n      } else if (parent2ClassName === ViewLine.CLASS_NAME) {\n        // it returned the `<span>` with the inline decoration\n        return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n      }\n    }\n    return new UnknownHitTestResult(hitResult.offsetNode);\n  }\n  static _snapToSoftTabBoundary(position, viewModel) {\n    const lineContent = viewModel.getLineContent(position.lineNumber);\n    const {\n      tabSize\n    } = viewModel.model.getOptions();\n    const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Direction.Nearest */);\n    if (newPosition !== -1) {\n      return new Position(position.lineNumber, newPosition + 1);\n    }\n    return position;\n  }\n  static doHitTest(ctx, request) {\n    let result = new UnknownHitTestResult();\n    if (typeof ctx.viewDomNode.ownerDocument.caretRangeFromPoint === 'function') {\n      result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n    } else if (ctx.viewDomNode.ownerDocument.caretPositionFromPoint) {\n      result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n    }\n    if (result.type === 1 /* HitTestResultType.Content */) {\n      const injectedText = ctx.viewModel.getInjectedTextAt(result.position);\n      const normalizedPosition = ctx.viewModel.normalizePosition(result.position, 2 /* PositionAffinity.None */);\n      if (injectedText || !normalizedPosition.equals(result.position)) {\n        result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n      }\n    }\n    return result;\n  }\n}\nfunction shadowCaretRangeFromPoint(shadowRoot, x, y) {\n  const range = document.createRange();\n  // Get the element under the point\n  let el = shadowRoot.elementFromPoint(x, y);\n  if (el !== null) {\n    // Get the last child of the element until its firstChild is a text node\n    // This assumes that the pointer is on the right of the line, out of the tokens\n    // and that we want to get the offset of the last token of the line\n    while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n      el = el.lastChild;\n    }\n    // Grab its rect\n    const rect = el.getBoundingClientRect();\n    // And its font (the computed shorthand font property might be empty, see #3217)\n    const elWindow = dom.getWindow(el);\n    const fontStyle = elWindow.getComputedStyle(el, null).getPropertyValue('font-style');\n    const fontVariant = elWindow.getComputedStyle(el, null).getPropertyValue('font-variant');\n    const fontWeight = elWindow.getComputedStyle(el, null).getPropertyValue('font-weight');\n    const fontSize = elWindow.getComputedStyle(el, null).getPropertyValue('font-size');\n    const lineHeight = elWindow.getComputedStyle(el, null).getPropertyValue('line-height');\n    const fontFamily = elWindow.getComputedStyle(el, null).getPropertyValue('font-family');\n    const font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;\n    // And also its txt content\n    const text = el.innerText;\n    // Position the pixel cursor at the left of the element\n    let pixelCursor = rect.left;\n    let offset = 0;\n    let step;\n    // If the point is on the right of the box put the cursor after the last character\n    if (x > rect.left + rect.width) {\n      offset = text.length;\n    } else {\n      const charWidthReader = CharWidthReader.getInstance();\n      // Goes through all the characters of the innerText, and checks if the x of the point\n      // belongs to the character.\n      for (let i = 0; i < text.length + 1; i++) {\n        // The step is half the width of the character\n        step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n        // Move to the center of the character\n        pixelCursor += step;\n        // If the x of the point is smaller that the position of the cursor, the point is over that character\n        if (x < pixelCursor) {\n          offset = i;\n          break;\n        }\n        // Move between the current character and the next\n        pixelCursor += step;\n      }\n    }\n    // Creates a range with the text node of the element and set the offset found\n    range.setStart(el.firstChild, offset);\n    range.setEnd(el.firstChild, offset);\n  }\n  return range;\n}\nclass CharWidthReader {\n  static getInstance() {\n    if (!CharWidthReader._INSTANCE) {\n      CharWidthReader._INSTANCE = new CharWidthReader();\n    }\n    return CharWidthReader._INSTANCE;\n  }\n  constructor() {\n    this._cache = {};\n    this._canvas = document.createElement('canvas');\n  }\n  getCharWidth(char, font) {\n    const cacheKey = char + font;\n    if (this._cache[cacheKey]) {\n      return this._cache[cacheKey];\n    }\n    const context = this._canvas.getContext('2d');\n    context.font = font;\n    const metrics = context.measureText(char);\n    const width = metrics.width;\n    this._cache[cacheKey] = width;\n    return width;\n  }\n}\n_CharWidthReader = CharWidthReader;\n_CharWidthReader._INSTANCE = null;","map":{"version":3,"names":["PageCoordinates","PartFingerprints","ViewLine","Position","Range","EditorRange","CursorColumns","dom","AtomicTabMoveOperations","Lazy","UnknownHitTestResult","constructor","hitTarget","type","ContentHitTestResult","spanNode","position","injectedText","HitTestResult","createFromDOMInfo","ctx","offset","getPositionFromDOMInfo","PointerHandlerLastRenderData","lastViewCursorsRenderData","lastTextareaPosition","MouseTarget","_deduceRage","range","lineNumber","column","createUnknown","element","mouseColumn","createTextarea","createMargin","detail","createViewZone","createContentText","createContentEmpty","createContentWidget","createScrollbar","createOverlayWidget","createOutsideEditor","outsidePosition","outsideDistance","_typeToString","toString","target","JSON","stringify","ElementPath","isTextArea","path","length","isChildOfViewLines","isStrictChildOfViewLines","isChildOfScrollableElement","isChildOfMinimap","isChildOfContentWidgets","isChildOfOverflowGuard","isChildOfOverflowingContentWidgets","isChildOfOverlayWidgets","isChildOfOverflowingOverlayWidgets","HitTestContext","context","viewHelper","lastRenderData","viewModel","options","configuration","layoutInfo","get","viewDomNode","overflowWidgetsDomNode","lineHeight","stickyTabStops","typicalHalfwidthCharacterWidth","_context","_viewHelper","getZoneAtCoord","mouseVerticalOffset","viewZoneWhitespace","viewLayout","getWhitespaceAtVerticalOffset","viewZoneMiddle","verticalOffset","height","lineCount","getLineCount","positionBefore","positionAfter","afterLineNumber","getLineMaxColumn","viewZoneId","id","getFullLineRangeAtCoord","isAfterLines","maxLineColumn","getLineNumberAtVerticalOffset","isInTopPadding","isInBottomPadding","getVerticalOffsetForLineNumber","findAttribute","attr","_findAttribute","stopAt","ownerDocument","body","hasAttribute","getAttribute","parentNode","getLineWidth","visibleRangeForPosition","getCurrentScrollTop","getCurrentScrollLeft","BareHitTestRequest","editorPos","pos","relativePos","Math","max","y","mouseContentHorizontalOffset","x","contentLeft","isInMarginArea","glyphMarginLeft","isInContentArea","MouseTargetFactory","_getMouseColumn","HitTestRequest","_useHitTestTarget","hitTestResult","value","_eventTarget","targetPath","_targetPathCacheElement","_targetElement","_targetPathCacheValue","collect","eventTarget","targetElement","doHitTest","_ctx","Uint8Array","hasEventTarget","Boolean","outerHTML","wouldBenefitFromHitTestTargetSwitch","switchToHitTestTarget","visibleColumnFromColumn","getLineContent","model","getOptions","tabSize","fulfillUnknown","fulfillTextarea","fulfillMargin","fulfillViewZone","fulfillContentText","fulfillContentEmpty","fulfillContentWidget","fulfillScrollbar","fulfillOverlayWidget","EMPTY_CONTENT_AFTER_LINES","createEmptyContentDataInLines","horizontalDistanceToText","mouseTargetIsWidget","e","t","createMouseTargetForView","request","r","_createMouseTarget","_snapToSoftTabBoundary","fromPositions","plusRange","err","createMouseTargetForOverflowWidgetsDomNode","resolvedRequest","result","_hitTestContentWidget","_hitTestOverlayWidget","_hitTestMinimap","_hitTestScrollbarSlider","_hitTestViewZone","_hitTestMargin","_hitTestViewCursor","_hitTestTextArea","_hitTestViewLines","_hitTestScrollbar","widgetId","d","domNode","mightBeForeignElement","width","cursorVerticalOffset","viewZoneData","mouseTargetType","res","getStartPosition","abs","glyphMarginWidth","lineNumbersWidth","offsetX","modelCoordinate","coordinatesConverter","convertViewPositionToModelPosition","lanes","glyphLanes","getLanesAtLine","glyphMarginLane","floor","getLineLength","lineWidth","createMouseTargetFromHitTestPosition","possibleLineNumber","maxColumn","nodeType","className","test","getMouseColumn","chars","round","visibleRange","columnHorizontalOffset","left","points","push","lineMaxColumn","sort","a","b","mouseCoordinates","toClientCoordinates","getWindow","spanNodeClientRect","getBoundingClientRect","mouseIsOverSpanNode","clientX","right","rng","i","prev","curr","prevDelta","nextDelta","_doHitTestWithCaretRangeFromPoint","lineStartVerticalOffset","lineEndVerticalOffset","isBelowLastLine","lineCenteredVerticalOffset","adjustedPageY","adjustedPage","_actualDoHitTestWithCaretRangeFromPoint","coords","shadowRoot","getShadowRoot","caretRangeFromPoint","shadowCaretRangeFromPoint","clientY","startContainer","TEXT_NODE","parent1","parent2","parent3","parent3ClassName","ELEMENT_NODE","CLASS_NAME","startOffset","parent2ClassName","textContent","_doHitTestWithCaretPositionFromPoint","hitResult","caretPositionFromPoint","offsetNode","parent1ClassName","tokenSpan","childNodes","min","lineContent","newPosition","atomicPosition","getInjectedTextAt","normalizedPosition","normalizePosition","equals","document","createRange","el","elementFromPoint","firstChild","lastChild","rect","elWindow","fontStyle","getComputedStyle","getPropertyValue","fontVariant","fontWeight","fontSize","fontFamily","font","text","innerText","pixelCursor","step","charWidthReader","CharWidthReader","getInstance","getCharWidth","charAt","setStart","setEnd","_INSTANCE","_cache","_canvas","createElement","char","cacheKey","getContext","metrics","measureText","_CharWidthReader"],"sources":["C:/Users/ruzhe/CODEHUB-PH/GAMES/code-master/node_modules/monaco-editor/esm/vs/editor/browser/controller/mouseTarget.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { PageCoordinates } from '../editorDom.js';\nimport { PartFingerprints } from '../view/viewPart.js';\nimport { ViewLine } from '../viewParts/lines/viewLine.js';\nimport { Position } from '../../common/core/position.js';\nimport { Range as EditorRange } from '../../common/core/range.js';\nimport { CursorColumns } from '../../common/core/cursorColumns.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { AtomicTabMoveOperations } from '../../common/cursor/cursorAtomicMoveOperations.js';\nimport { Lazy } from '../../../base/common/lazy.js';\nclass UnknownHitTestResult {\n    constructor(hitTarget = null) {\n        this.hitTarget = hitTarget;\n        this.type = 0 /* HitTestResultType.Unknown */;\n    }\n}\nclass ContentHitTestResult {\n    get hitTarget() { return this.spanNode; }\n    constructor(position, spanNode, injectedText) {\n        this.position = position;\n        this.spanNode = spanNode;\n        this.injectedText = injectedText;\n        this.type = 1 /* HitTestResultType.Content */;\n    }\n}\nvar HitTestResult;\n(function (HitTestResult) {\n    function createFromDOMInfo(ctx, spanNode, offset) {\n        const position = ctx.getPositionFromDOMInfo(spanNode, offset);\n        if (position) {\n            return new ContentHitTestResult(position, spanNode, null);\n        }\n        return new UnknownHitTestResult(spanNode);\n    }\n    HitTestResult.createFromDOMInfo = createFromDOMInfo;\n})(HitTestResult || (HitTestResult = {}));\nexport class PointerHandlerLastRenderData {\n    constructor(lastViewCursorsRenderData, lastTextareaPosition) {\n        this.lastViewCursorsRenderData = lastViewCursorsRenderData;\n        this.lastTextareaPosition = lastTextareaPosition;\n    }\n}\nexport class MouseTarget {\n    static _deduceRage(position, range = null) {\n        if (!range && position) {\n            return new EditorRange(position.lineNumber, position.column, position.lineNumber, position.column);\n        }\n        return range ?? null;\n    }\n    static createUnknown(element, mouseColumn, position) {\n        return { type: 0 /* MouseTargetType.UNKNOWN */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createTextarea(element, mouseColumn) {\n        return { type: 1 /* MouseTargetType.TEXTAREA */, element, mouseColumn, position: null, range: null };\n    }\n    static createMargin(type, element, mouseColumn, position, range, detail) {\n        return { type, element, mouseColumn, position, range, detail };\n    }\n    static createViewZone(type, element, mouseColumn, position, detail) {\n        return { type, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentText(element, mouseColumn, position, range, detail) {\n        return { type: 6 /* MouseTargetType.CONTENT_TEXT */, element, mouseColumn, position, range: this._deduceRage(position, range), detail };\n    }\n    static createContentEmpty(element, mouseColumn, position, detail) {\n        return { type: 7 /* MouseTargetType.CONTENT_EMPTY */, element, mouseColumn, position, range: this._deduceRage(position), detail };\n    }\n    static createContentWidget(element, mouseColumn, detail) {\n        return { type: 9 /* MouseTargetType.CONTENT_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createScrollbar(element, mouseColumn, position) {\n        return { type: 11 /* MouseTargetType.SCROLLBAR */, element, mouseColumn, position, range: this._deduceRage(position) };\n    }\n    static createOverlayWidget(element, mouseColumn, detail) {\n        return { type: 12 /* MouseTargetType.OVERLAY_WIDGET */, element, mouseColumn, position: null, range: null, detail };\n    }\n    static createOutsideEditor(mouseColumn, position, outsidePosition, outsideDistance) {\n        return { type: 13 /* MouseTargetType.OUTSIDE_EDITOR */, element: null, mouseColumn, position, range: this._deduceRage(position), outsidePosition, outsideDistance };\n    }\n    static _typeToString(type) {\n        if (type === 1 /* MouseTargetType.TEXTAREA */) {\n            return 'TEXTAREA';\n        }\n        if (type === 2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */) {\n            return 'GUTTER_GLYPH_MARGIN';\n        }\n        if (type === 3 /* MouseTargetType.GUTTER_LINE_NUMBERS */) {\n            return 'GUTTER_LINE_NUMBERS';\n        }\n        if (type === 4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */) {\n            return 'GUTTER_LINE_DECORATIONS';\n        }\n        if (type === 5 /* MouseTargetType.GUTTER_VIEW_ZONE */) {\n            return 'GUTTER_VIEW_ZONE';\n        }\n        if (type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n            return 'CONTENT_TEXT';\n        }\n        if (type === 7 /* MouseTargetType.CONTENT_EMPTY */) {\n            return 'CONTENT_EMPTY';\n        }\n        if (type === 8 /* MouseTargetType.CONTENT_VIEW_ZONE */) {\n            return 'CONTENT_VIEW_ZONE';\n        }\n        if (type === 9 /* MouseTargetType.CONTENT_WIDGET */) {\n            return 'CONTENT_WIDGET';\n        }\n        if (type === 10 /* MouseTargetType.OVERVIEW_RULER */) {\n            return 'OVERVIEW_RULER';\n        }\n        if (type === 11 /* MouseTargetType.SCROLLBAR */) {\n            return 'SCROLLBAR';\n        }\n        if (type === 12 /* MouseTargetType.OVERLAY_WIDGET */) {\n            return 'OVERLAY_WIDGET';\n        }\n        return 'UNKNOWN';\n    }\n    static toString(target) {\n        return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + JSON.stringify(target.detail);\n    }\n}\nclass ElementPath {\n    static isTextArea(path) {\n        return (path.length === 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 7 /* PartFingerprint.TextArea */);\n    }\n    static isChildOfViewLines(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 8 /* PartFingerprint.ViewLines */);\n    }\n    static isStrictChildOfViewLines(path) {\n        return (path.length > 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 8 /* PartFingerprint.ViewLines */);\n    }\n    static isChildOfScrollableElement(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 6 /* PartFingerprint.ScrollableElement */);\n    }\n    static isChildOfMinimap(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 9 /* PartFingerprint.Minimap */);\n    }\n    static isChildOfContentWidgets(path) {\n        return (path.length >= 4\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[3] === 1 /* PartFingerprint.ContentWidgets */);\n    }\n    static isChildOfOverflowGuard(path) {\n        return (path.length >= 1\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */);\n    }\n    static isChildOfOverflowingContentWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 2 /* PartFingerprint.OverflowingContentWidgets */);\n    }\n    static isChildOfOverlayWidgets(path) {\n        return (path.length >= 2\n            && path[0] === 3 /* PartFingerprint.OverflowGuard */\n            && path[1] === 4 /* PartFingerprint.OverlayWidgets */);\n    }\n    static isChildOfOverflowingOverlayWidgets(path) {\n        return (path.length >= 1\n            && path[0] === 5 /* PartFingerprint.OverflowingOverlayWidgets */);\n    }\n}\nexport class HitTestContext {\n    constructor(context, viewHelper, lastRenderData) {\n        this.viewModel = context.viewModel;\n        const options = context.configuration.options;\n        this.layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        this.viewDomNode = viewHelper.viewDomNode;\n        this.overflowWidgetsDomNode = viewHelper.overflowWidgetsDomNode ?? null;\n        this.lineHeight = options.get(67 /* EditorOption.lineHeight */);\n        this.stickyTabStops = options.get(117 /* EditorOption.stickyTabStops */);\n        this.typicalHalfwidthCharacterWidth = options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth;\n        this.lastRenderData = lastRenderData;\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    getZoneAtCoord(mouseVerticalOffset) {\n        return HitTestContext.getZoneAtCoord(this._context, mouseVerticalOffset);\n    }\n    static getZoneAtCoord(context, mouseVerticalOffset) {\n        // The target is either a view zone or the empty space after the last view-line\n        const viewZoneWhitespace = context.viewLayout.getWhitespaceAtVerticalOffset(mouseVerticalOffset);\n        if (viewZoneWhitespace) {\n            const viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2;\n            const lineCount = context.viewModel.getLineCount();\n            let positionBefore = null;\n            let position;\n            let positionAfter = null;\n            if (viewZoneWhitespace.afterLineNumber !== lineCount) {\n                // There are more lines after this view zone\n                positionAfter = new Position(viewZoneWhitespace.afterLineNumber + 1, 1);\n            }\n            if (viewZoneWhitespace.afterLineNumber > 0) {\n                // There are more lines above this view zone\n                positionBefore = new Position(viewZoneWhitespace.afterLineNumber, context.viewModel.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));\n            }\n            if (positionAfter === null) {\n                position = positionBefore;\n            }\n            else if (positionBefore === null) {\n                position = positionAfter;\n            }\n            else if (mouseVerticalOffset < viewZoneMiddle) {\n                position = positionBefore;\n            }\n            else {\n                position = positionAfter;\n            }\n            return {\n                viewZoneId: viewZoneWhitespace.id,\n                afterLineNumber: viewZoneWhitespace.afterLineNumber,\n                positionBefore: positionBefore,\n                positionAfter: positionAfter,\n                position: position\n            };\n        }\n        return null;\n    }\n    getFullLineRangeAtCoord(mouseVerticalOffset) {\n        if (this._context.viewLayout.isAfterLines(mouseVerticalOffset)) {\n            // Below the last line\n            const lineNumber = this._context.viewModel.getLineCount();\n            const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n            return {\n                range: new EditorRange(lineNumber, maxLineColumn, lineNumber, maxLineColumn),\n                isAfterLines: true\n            };\n        }\n        const lineNumber = this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n        const maxLineColumn = this._context.viewModel.getLineMaxColumn(lineNumber);\n        return {\n            range: new EditorRange(lineNumber, 1, lineNumber, maxLineColumn),\n            isAfterLines: false\n        };\n    }\n    getLineNumberAtVerticalOffset(mouseVerticalOffset) {\n        return this._context.viewLayout.getLineNumberAtVerticalOffset(mouseVerticalOffset);\n    }\n    isAfterLines(mouseVerticalOffset) {\n        return this._context.viewLayout.isAfterLines(mouseVerticalOffset);\n    }\n    isInTopPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInTopPadding(mouseVerticalOffset);\n    }\n    isInBottomPadding(mouseVerticalOffset) {\n        return this._context.viewLayout.isInBottomPadding(mouseVerticalOffset);\n    }\n    getVerticalOffsetForLineNumber(lineNumber) {\n        return this._context.viewLayout.getVerticalOffsetForLineNumber(lineNumber);\n    }\n    findAttribute(element, attr) {\n        return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);\n    }\n    static _findAttribute(element, attr, stopAt) {\n        while (element && element !== element.ownerDocument.body) {\n            if (element.hasAttribute && element.hasAttribute(attr)) {\n                return element.getAttribute(attr);\n            }\n            if (element === stopAt) {\n                return null;\n            }\n            element = element.parentNode;\n        }\n        return null;\n    }\n    getLineWidth(lineNumber) {\n        return this._viewHelper.getLineWidth(lineNumber);\n    }\n    visibleRangeForPosition(lineNumber, column) {\n        return this._viewHelper.visibleRangeForPosition(lineNumber, column);\n    }\n    getPositionFromDOMInfo(spanNode, offset) {\n        return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);\n    }\n    getCurrentScrollTop() {\n        return this._context.viewLayout.getCurrentScrollTop();\n    }\n    getCurrentScrollLeft() {\n        return this._context.viewLayout.getCurrentScrollLeft();\n    }\n}\nclass BareHitTestRequest {\n    constructor(ctx, editorPos, pos, relativePos) {\n        this.editorPos = editorPos;\n        this.pos = pos;\n        this.relativePos = relativePos;\n        this.mouseVerticalOffset = Math.max(0, ctx.getCurrentScrollTop() + this.relativePos.y);\n        this.mouseContentHorizontalOffset = ctx.getCurrentScrollLeft() + this.relativePos.x - ctx.layoutInfo.contentLeft;\n        this.isInMarginArea = (this.relativePos.x < ctx.layoutInfo.contentLeft && this.relativePos.x >= ctx.layoutInfo.glyphMarginLeft);\n        this.isInContentArea = !this.isInMarginArea;\n        this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));\n    }\n}\nclass HitTestRequest extends BareHitTestRequest {\n    get target() {\n        if (this._useHitTestTarget) {\n            return this.hitTestResult.value.hitTarget;\n        }\n        return this._eventTarget;\n    }\n    get targetPath() {\n        if (this._targetPathCacheElement !== this.target && this._targetElement) {\n            this._targetPathCacheElement = this.target;\n            this._targetPathCacheValue = PartFingerprints.collect(this.target, this._targetElement);\n        }\n        return this._targetPathCacheValue;\n    }\n    constructor(ctx, editorPos, pos, relativePos, eventTarget, targetElement = null) {\n        super(ctx, editorPos, pos, relativePos);\n        this.hitTestResult = new Lazy(() => MouseTargetFactory.doHitTest(this._ctx, this));\n        this._targetPathCacheElement = null;\n        this._targetPathCacheValue = new Uint8Array(0);\n        this._targetElement = null;\n        this._ctx = ctx;\n        this._eventTarget = eventTarget;\n        this._targetElement = targetElement;\n        // If no event target is passed in, we will use the hit test target\n        const hasEventTarget = Boolean(this._eventTarget);\n        this._useHitTestTarget = !hasEventTarget;\n    }\n    toString() {\n        return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}\\n\\ttarget: ${this.target ? this.target.outerHTML : null}`;\n    }\n    get wouldBenefitFromHitTestTargetSwitch() {\n        return (!this._useHitTestTarget\n            && this.hitTestResult.value.hitTarget !== null\n            && this.target !== this.hitTestResult.value.hitTarget);\n    }\n    switchToHitTestTarget() {\n        this._useHitTestTarget = true;\n    }\n    _getMouseColumn(position = null) {\n        if (position && position.column < this._ctx.viewModel.getLineMaxColumn(position.lineNumber)) {\n            // Most likely, the line contains foreign decorations...\n            return CursorColumns.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(position.lineNumber), position.column, this._ctx.viewModel.model.getOptions().tabSize) + 1;\n        }\n        return this.mouseColumn;\n    }\n    fulfillUnknown(position = null) {\n        return MouseTarget.createUnknown(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillTextarea() {\n        return MouseTarget.createTextarea(this.target, this._getMouseColumn());\n    }\n    fulfillMargin(type, position, range, detail) {\n        return MouseTarget.createMargin(type, this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillViewZone(type, position, detail) {\n        return MouseTarget.createViewZone(type, this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentText(position, range, detail) {\n        return MouseTarget.createContentText(this.target, this._getMouseColumn(position), position, range, detail);\n    }\n    fulfillContentEmpty(position, detail) {\n        return MouseTarget.createContentEmpty(this.target, this._getMouseColumn(position), position, detail);\n    }\n    fulfillContentWidget(detail) {\n        return MouseTarget.createContentWidget(this.target, this._getMouseColumn(), detail);\n    }\n    fulfillScrollbar(position) {\n        return MouseTarget.createScrollbar(this.target, this._getMouseColumn(position), position);\n    }\n    fulfillOverlayWidget(detail) {\n        return MouseTarget.createOverlayWidget(this.target, this._getMouseColumn(), detail);\n    }\n}\nconst EMPTY_CONTENT_AFTER_LINES = { isAfterLines: true };\nfunction createEmptyContentDataInLines(horizontalDistanceToText) {\n    return {\n        isAfterLines: false,\n        horizontalDistanceToText: horizontalDistanceToText\n    };\n}\nexport class MouseTargetFactory {\n    constructor(context, viewHelper) {\n        this._context = context;\n        this._viewHelper = viewHelper;\n    }\n    mouseTargetIsWidget(e) {\n        const t = e.target;\n        const path = PartFingerprints.collect(t, this._viewHelper.viewDomNode);\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {\n            return true;\n        }\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(path) || ElementPath.isChildOfOverflowingOverlayWidgets(path)) {\n            return true;\n        }\n        return false;\n    }\n    createMouseTargetForView(lastRenderData, editorPos, pos, relativePos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target, ctx.viewDomNode);\n        try {\n            const r = MouseTargetFactory._createMouseTarget(ctx, request);\n            if (r.type === 6 /* MouseTargetType.CONTENT_TEXT */) {\n                // Snap to the nearest soft tab boundary if atomic soft tabs are enabled.\n                if (ctx.stickyTabStops && r.position !== null) {\n                    const position = MouseTargetFactory._snapToSoftTabBoundary(r.position, ctx.viewModel);\n                    const range = EditorRange.fromPositions(position, position).plusRange(r.range);\n                    return request.fulfillContentText(position, range, r.detail);\n                }\n            }\n            // console.log(MouseTarget.toString(r));\n            return r;\n        }\n        catch (err) {\n            // console.log(err);\n            return request.fulfillUnknown();\n        }\n    }\n    createMouseTargetForOverflowWidgetsDomNode(lastRenderData, editorPos, pos, relativePos, target) {\n        const ctx = new HitTestContext(this._context, this._viewHelper, lastRenderData);\n        const request = new HitTestRequest(ctx, editorPos, pos, relativePos, target, ctx.overflowWidgetsDomNode);\n        try {\n            return MouseTargetFactory._createMouseTarget(ctx, request);\n        }\n        catch (err) {\n            return request.fulfillUnknown();\n        }\n    }\n    static _createMouseTarget(ctx, request) {\n        // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);\n        if (request.target === null) {\n            // No target\n            return request.fulfillUnknown();\n        }\n        // we know for a fact that request.target is not null\n        const resolvedRequest = request;\n        let result = null;\n        if (!ElementPath.isChildOfOverflowGuard(request.targetPath) && !ElementPath.isChildOfOverflowingContentWidgets(request.targetPath) && !ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n            // We only render dom nodes inside the overflow guard or in the overflowing content widgets\n            result = result || request.fulfillUnknown();\n        }\n        result = result || MouseTargetFactory._hitTestContentWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMinimap(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbarSlider(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewZone(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestMargin(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewCursor(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestTextArea(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestViewLines(ctx, resolvedRequest);\n        result = result || MouseTargetFactory._hitTestScrollbar(ctx, resolvedRequest);\n        return (result || request.fulfillUnknown());\n    }\n    static _hitTestContentWidget(ctx, request) {\n        // Is it a content widget?\n        if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillContentWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestOverlayWidget(ctx, request) {\n        // Is it an overlay widget?\n        if (ElementPath.isChildOfOverlayWidgets(request.targetPath) || ElementPath.isChildOfOverflowingOverlayWidgets(request.targetPath)) {\n            const widgetId = ctx.findAttribute(request.target, 'widgetId');\n            if (widgetId) {\n                return request.fulfillOverlayWidget(widgetId);\n            }\n            else {\n                return request.fulfillUnknown();\n            }\n        }\n        return null;\n    }\n    static _hitTestViewCursor(ctx, request) {\n        if (request.target) {\n            // Check if we've hit a painted cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            for (const d of lastViewCursorsRenderData) {\n                if (request.target === d.domNode) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        if (request.isInContentArea) {\n            // Edge has a bug when hit-testing the exact position of a cursor,\n            // instead of returning the correct dom node, it returns the\n            // first or last rendered view line dom node, therefore help it out\n            // and first check if we are on top of a cursor\n            const lastViewCursorsRenderData = ctx.lastRenderData.lastViewCursorsRenderData;\n            const mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;\n            const mouseVerticalOffset = request.mouseVerticalOffset;\n            for (const d of lastViewCursorsRenderData) {\n                if (mouseContentHorizontalOffset < d.contentLeft) {\n                    // mouse position is to the left of the cursor\n                    continue;\n                }\n                if (mouseContentHorizontalOffset > d.contentLeft + d.width) {\n                    // mouse position is to the right of the cursor\n                    continue;\n                }\n                const cursorVerticalOffset = ctx.getVerticalOffsetForLineNumber(d.position.lineNumber);\n                if (cursorVerticalOffset <= mouseVerticalOffset\n                    && mouseVerticalOffset <= cursorVerticalOffset + d.height) {\n                    return request.fulfillContentText(d.position, null, { mightBeForeignElement: false, injectedText: null });\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestViewZone(ctx, request) {\n        const viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);\n        if (viewZoneData) {\n            const mouseTargetType = (request.isInContentArea ? 8 /* MouseTargetType.CONTENT_VIEW_ZONE */ : 5 /* MouseTargetType.GUTTER_VIEW_ZONE */);\n            return request.fulfillViewZone(mouseTargetType, viewZoneData.position, viewZoneData);\n        }\n        return null;\n    }\n    static _hitTestTextArea(ctx, request) {\n        // Is it the textarea?\n        if (ElementPath.isTextArea(request.targetPath)) {\n            if (ctx.lastRenderData.lastTextareaPosition) {\n                return request.fulfillContentText(ctx.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: false, injectedText: null });\n            }\n            return request.fulfillTextarea();\n        }\n        return null;\n    }\n    static _hitTestMargin(ctx, request) {\n        if (request.isInMarginArea) {\n            const res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);\n            const pos = res.range.getStartPosition();\n            let offset = Math.abs(request.relativePos.x);\n            const detail = {\n                isAfterLines: res.isAfterLines,\n                glyphMarginLeft: ctx.layoutInfo.glyphMarginLeft,\n                glyphMarginWidth: ctx.layoutInfo.glyphMarginWidth,\n                lineNumbersWidth: ctx.layoutInfo.lineNumbersWidth,\n                offsetX: offset\n            };\n            offset -= ctx.layoutInfo.glyphMarginLeft;\n            if (offset <= ctx.layoutInfo.glyphMarginWidth) {\n                // On the glyph margin\n                const modelCoordinate = ctx.viewModel.coordinatesConverter.convertViewPositionToModelPosition(res.range.getStartPosition());\n                const lanes = ctx.viewModel.glyphLanes.getLanesAtLine(modelCoordinate.lineNumber);\n                detail.glyphMarginLane = lanes[Math.floor(offset / ctx.lineHeight)];\n                return request.fulfillMargin(2 /* MouseTargetType.GUTTER_GLYPH_MARGIN */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.glyphMarginWidth;\n            if (offset <= ctx.layoutInfo.lineNumbersWidth) {\n                // On the line numbers\n                return request.fulfillMargin(3 /* MouseTargetType.GUTTER_LINE_NUMBERS */, pos, res.range, detail);\n            }\n            offset -= ctx.layoutInfo.lineNumbersWidth;\n            // On the line decorations\n            return request.fulfillMargin(4 /* MouseTargetType.GUTTER_LINE_DECORATIONS */, pos, res.range, detail);\n        }\n        return null;\n    }\n    static _hitTestViewLines(ctx, request) {\n        if (!ElementPath.isChildOfViewLines(request.targetPath)) {\n            return null;\n        }\n        if (ctx.isInTopPadding(request.mouseVerticalOffset)) {\n            return request.fulfillContentEmpty(new Position(1, 1), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if it is below any lines and any view zones\n        if (ctx.isAfterLines(request.mouseVerticalOffset) || ctx.isInBottomPadding(request.mouseVerticalOffset)) {\n            // This most likely indicates it happened after the last view-line\n            const lineCount = ctx.viewModel.getLineCount();\n            const maxLineColumn = ctx.viewModel.getLineMaxColumn(lineCount);\n            return request.fulfillContentEmpty(new Position(lineCount, maxLineColumn), EMPTY_CONTENT_AFTER_LINES);\n        }\n        // Check if we are hitting a view-line (can happen in the case of inline decorations on empty lines)\n        // See https://github.com/microsoft/vscode/issues/46942\n        if (ElementPath.isStrictChildOfViewLines(request.targetPath)) {\n            const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            if (ctx.viewModel.getLineLength(lineNumber) === 0) {\n                const lineWidth = ctx.getLineWidth(lineNumber);\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                return request.fulfillContentEmpty(new Position(lineNumber, 1), detail);\n            }\n            const lineWidth = ctx.getLineWidth(lineNumber);\n            if (request.mouseContentHorizontalOffset >= lineWidth) {\n                // TODO: This is wrong for RTL\n                const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n                const pos = new Position(lineNumber, ctx.viewModel.getLineMaxColumn(lineNumber));\n                return request.fulfillContentEmpty(pos, detail);\n            }\n        }\n        // Do the hit test (if not already done)\n        const hitTestResult = request.hitTestResult.value;\n        if (hitTestResult.type === 1 /* HitTestResultType.Content */) {\n            return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.spanNode, hitTestResult.position, hitTestResult.injectedText);\n        }\n        // We didn't hit content...\n        if (request.wouldBenefitFromHitTestTargetSwitch) {\n            // We actually hit something different... Give it one last change by trying again with this new target\n            request.switchToHitTestTarget();\n            return this._createMouseTarget(ctx, request);\n        }\n        // We have tried everything...\n        return request.fulfillUnknown();\n    }\n    static _hitTestMinimap(ctx, request) {\n        if (ElementPath.isChildOfMinimap(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    static _hitTestScrollbarSlider(ctx, request) {\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            if (request.target && request.target.nodeType === 1) {\n                const className = request.target.className;\n                if (className && /\\b(slider|scrollbar)\\b/.test(className)) {\n                    const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n                    const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n                    return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n                }\n            }\n        }\n        return null;\n    }\n    static _hitTestScrollbar(ctx, request) {\n        // Is it the overview ruler?\n        // Is it a child of the scrollable element?\n        if (ElementPath.isChildOfScrollableElement(request.targetPath)) {\n            const possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n            const maxColumn = ctx.viewModel.getLineMaxColumn(possibleLineNumber);\n            return request.fulfillScrollbar(new Position(possibleLineNumber, maxColumn));\n        }\n        return null;\n    }\n    getMouseColumn(relativePos) {\n        const options = this._context.configuration.options;\n        const layoutInfo = options.get(146 /* EditorOption.layoutInfo */);\n        const mouseContentHorizontalOffset = this._context.viewLayout.getCurrentScrollLeft() + relativePos.x - layoutInfo.contentLeft;\n        return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, options.get(50 /* EditorOption.fontInfo */).typicalHalfwidthCharacterWidth);\n    }\n    static _getMouseColumn(mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {\n        if (mouseContentHorizontalOffset < 0) {\n            return 1;\n        }\n        const chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);\n        return (chars + 1);\n    }\n    static createMouseTargetFromHitTestPosition(ctx, request, spanNode, pos, injectedText) {\n        const lineNumber = pos.lineNumber;\n        const column = pos.column;\n        const lineWidth = ctx.getLineWidth(lineNumber);\n        if (request.mouseContentHorizontalOffset > lineWidth) {\n            const detail = createEmptyContentDataInLines(request.mouseContentHorizontalOffset - lineWidth);\n            return request.fulfillContentEmpty(pos, detail);\n        }\n        const visibleRange = ctx.visibleRangeForPosition(lineNumber, column);\n        if (!visibleRange) {\n            return request.fulfillUnknown(pos);\n        }\n        const columnHorizontalOffset = visibleRange.left;\n        if (Math.abs(request.mouseContentHorizontalOffset - columnHorizontalOffset) < 1) {\n            return request.fulfillContentText(pos, null, { mightBeForeignElement: !!injectedText, injectedText });\n        }\n        const points = [];\n        points.push({ offset: visibleRange.left, column: column });\n        if (column > 1) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column - 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column - 1 });\n            }\n        }\n        const lineMaxColumn = ctx.viewModel.getLineMaxColumn(lineNumber);\n        if (column < lineMaxColumn) {\n            const visibleRange = ctx.visibleRangeForPosition(lineNumber, column + 1);\n            if (visibleRange) {\n                points.push({ offset: visibleRange.left, column: column + 1 });\n            }\n        }\n        points.sort((a, b) => a.offset - b.offset);\n        const mouseCoordinates = request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode));\n        const spanNodeClientRect = spanNode.getBoundingClientRect();\n        const mouseIsOverSpanNode = (spanNodeClientRect.left <= mouseCoordinates.clientX && mouseCoordinates.clientX <= spanNodeClientRect.right);\n        let rng = null;\n        for (let i = 1; i < points.length; i++) {\n            const prev = points[i - 1];\n            const curr = points[i];\n            if (prev.offset <= request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset <= curr.offset) {\n                rng = new EditorRange(lineNumber, prev.column, lineNumber, curr.column);\n                // See https://github.com/microsoft/vscode/issues/152819\n                // Due to the use of zwj, the browser's hit test result is skewed towards the left\n                // Here we try to correct that if the mouse horizontal offset is closer to the right than the left\n                const prevDelta = Math.abs(prev.offset - request.mouseContentHorizontalOffset);\n                const nextDelta = Math.abs(curr.offset - request.mouseContentHorizontalOffset);\n                pos = (prevDelta < nextDelta\n                    ? new Position(lineNumber, prev.column)\n                    : new Position(lineNumber, curr.column));\n                break;\n            }\n        }\n        return request.fulfillContentText(pos, rng, { mightBeForeignElement: !mouseIsOverSpanNode || !!injectedText, injectedText });\n    }\n    /**\n     * Most probably WebKit browsers and Edge\n     */\n    static _doHitTestWithCaretRangeFromPoint(ctx, request) {\n        // In Chrome, especially on Linux it is possible to click between lines,\n        // so try to adjust the `hity` below so that it lands in the center of a line\n        const lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);\n        const lineStartVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);\n        const lineEndVerticalOffset = lineStartVerticalOffset + ctx.lineHeight;\n        const isBelowLastLine = (lineNumber === ctx.viewModel.getLineCount()\n            && request.mouseVerticalOffset > lineEndVerticalOffset);\n        if (!isBelowLastLine) {\n            const lineCenteredVerticalOffset = Math.floor((lineStartVerticalOffset + lineEndVerticalOffset) / 2);\n            let adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);\n            if (adjustedPageY <= request.editorPos.y) {\n                adjustedPageY = request.editorPos.y + 1;\n            }\n            if (adjustedPageY >= request.editorPos.y + request.editorPos.height) {\n                adjustedPageY = request.editorPos.y + request.editorPos.height - 1;\n            }\n            const adjustedPage = new PageCoordinates(request.pos.x, adjustedPageY);\n            const r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n            if (r.type === 1 /* HitTestResultType.Content */) {\n                return r;\n            }\n        }\n        // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)\n        return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n    }\n    static _actualDoHitTestWithCaretRangeFromPoint(ctx, coords) {\n        const shadowRoot = dom.getShadowRoot(ctx.viewDomNode);\n        let range;\n        if (shadowRoot) {\n            if (typeof shadowRoot.caretRangeFromPoint === 'undefined') {\n                range = shadowCaretRangeFromPoint(shadowRoot, coords.clientX, coords.clientY);\n            }\n            else {\n                range = shadowRoot.caretRangeFromPoint(coords.clientX, coords.clientY);\n            }\n        }\n        else {\n            range = ctx.viewDomNode.ownerDocument.caretRangeFromPoint(coords.clientX, coords.clientY);\n        }\n        if (!range || !range.startContainer) {\n            return new UnknownHitTestResult();\n        }\n        // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span\n        const startContainer = range.startContainer;\n        if (startContainer.nodeType === startContainer.TEXT_NODE) {\n            // startContainer is expected to be the token text\n            const parent1 = startContainer.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, parent1, range.startOffset);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer.parentNode);\n            }\n        }\n        else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {\n            // startContainer is expected to be the token span\n            const parent1 = startContainer.parentNode; // expected to be the view line container span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent2ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, startContainer, startContainer.textContent.length);\n            }\n            else {\n                return new UnknownHitTestResult(startContainer);\n            }\n        }\n        return new UnknownHitTestResult();\n    }\n    /**\n     * Most probably Gecko\n     */\n    static _doHitTestWithCaretPositionFromPoint(ctx, coords) {\n        const hitResult = ctx.viewDomNode.ownerDocument.caretPositionFromPoint(coords.clientX, coords.clientY);\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {\n            // offsetNode is expected to be the token text\n            const parent1 = hitResult.offsetNode.parentNode; // expected to be the token span\n            const parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span\n            const parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div\n            const parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;\n            if (parent3ClassName === ViewLine.CLASS_NAME) {\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode.parentNode, hitResult.offset);\n            }\n            else {\n                return new UnknownHitTestResult(hitResult.offsetNode.parentNode);\n            }\n        }\n        // For inline decorations, Gecko sometimes returns the `<span>` of the line and the offset is the `<span>` with the inline decoration\n        // Some other times, it returns the `<span>` with the inline decoration\n        if (hitResult.offsetNode.nodeType === hitResult.offsetNode.ELEMENT_NODE) {\n            const parent1 = hitResult.offsetNode.parentNode;\n            const parent1ClassName = parent1 && parent1.nodeType === parent1.ELEMENT_NODE ? parent1.className : null;\n            const parent2 = parent1 ? parent1.parentNode : null;\n            const parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;\n            if (parent1ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` of the line and the offset is the `<span>` with the inline decoration\n                const tokenSpan = hitResult.offsetNode.childNodes[Math.min(hitResult.offset, hitResult.offsetNode.childNodes.length - 1)];\n                if (tokenSpan) {\n                    return HitTestResult.createFromDOMInfo(ctx, tokenSpan, 0);\n                }\n            }\n            else if (parent2ClassName === ViewLine.CLASS_NAME) {\n                // it returned the `<span>` with the inline decoration\n                return HitTestResult.createFromDOMInfo(ctx, hitResult.offsetNode, 0);\n            }\n        }\n        return new UnknownHitTestResult(hitResult.offsetNode);\n    }\n    static _snapToSoftTabBoundary(position, viewModel) {\n        const lineContent = viewModel.getLineContent(position.lineNumber);\n        const { tabSize } = viewModel.model.getOptions();\n        const newPosition = AtomicTabMoveOperations.atomicPosition(lineContent, position.column - 1, tabSize, 2 /* Direction.Nearest */);\n        if (newPosition !== -1) {\n            return new Position(position.lineNumber, newPosition + 1);\n        }\n        return position;\n    }\n    static doHitTest(ctx, request) {\n        let result = new UnknownHitTestResult();\n        if (typeof ctx.viewDomNode.ownerDocument.caretRangeFromPoint === 'function') {\n            result = this._doHitTestWithCaretRangeFromPoint(ctx, request);\n        }\n        else if (ctx.viewDomNode.ownerDocument.caretPositionFromPoint) {\n            result = this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates(dom.getWindow(ctx.viewDomNode)));\n        }\n        if (result.type === 1 /* HitTestResultType.Content */) {\n            const injectedText = ctx.viewModel.getInjectedTextAt(result.position);\n            const normalizedPosition = ctx.viewModel.normalizePosition(result.position, 2 /* PositionAffinity.None */);\n            if (injectedText || !normalizedPosition.equals(result.position)) {\n                result = new ContentHitTestResult(normalizedPosition, result.spanNode, injectedText);\n            }\n        }\n        return result;\n    }\n}\nfunction shadowCaretRangeFromPoint(shadowRoot, x, y) {\n    const range = document.createRange();\n    // Get the element under the point\n    let el = shadowRoot.elementFromPoint(x, y);\n    if (el !== null) {\n        // Get the last child of the element until its firstChild is a text node\n        // This assumes that the pointer is on the right of the line, out of the tokens\n        // and that we want to get the offset of the last token of the line\n        while (el && el.firstChild && el.firstChild.nodeType !== el.firstChild.TEXT_NODE && el.lastChild && el.lastChild.firstChild) {\n            el = el.lastChild;\n        }\n        // Grab its rect\n        const rect = el.getBoundingClientRect();\n        // And its font (the computed shorthand font property might be empty, see #3217)\n        const elWindow = dom.getWindow(el);\n        const fontStyle = elWindow.getComputedStyle(el, null).getPropertyValue('font-style');\n        const fontVariant = elWindow.getComputedStyle(el, null).getPropertyValue('font-variant');\n        const fontWeight = elWindow.getComputedStyle(el, null).getPropertyValue('font-weight');\n        const fontSize = elWindow.getComputedStyle(el, null).getPropertyValue('font-size');\n        const lineHeight = elWindow.getComputedStyle(el, null).getPropertyValue('line-height');\n        const fontFamily = elWindow.getComputedStyle(el, null).getPropertyValue('font-family');\n        const font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;\n        // And also its txt content\n        const text = el.innerText;\n        // Position the pixel cursor at the left of the element\n        let pixelCursor = rect.left;\n        let offset = 0;\n        let step;\n        // If the point is on the right of the box put the cursor after the last character\n        if (x > rect.left + rect.width) {\n            offset = text.length;\n        }\n        else {\n            const charWidthReader = CharWidthReader.getInstance();\n            // Goes through all the characters of the innerText, and checks if the x of the point\n            // belongs to the character.\n            for (let i = 0; i < text.length + 1; i++) {\n                // The step is half the width of the character\n                step = charWidthReader.getCharWidth(text.charAt(i), font) / 2;\n                // Move to the center of the character\n                pixelCursor += step;\n                // If the x of the point is smaller that the position of the cursor, the point is over that character\n                if (x < pixelCursor) {\n                    offset = i;\n                    break;\n                }\n                // Move between the current character and the next\n                pixelCursor += step;\n            }\n        }\n        // Creates a range with the text node of the element and set the offset found\n        range.setStart(el.firstChild, offset);\n        range.setEnd(el.firstChild, offset);\n    }\n    return range;\n}\nclass CharWidthReader {\n    static { this._INSTANCE = null; }\n    static getInstance() {\n        if (!CharWidthReader._INSTANCE) {\n            CharWidthReader._INSTANCE = new CharWidthReader();\n        }\n        return CharWidthReader._INSTANCE;\n    }\n    constructor() {\n        this._cache = {};\n        this._canvas = document.createElement('canvas');\n    }\n    getCharWidth(char, font) {\n        const cacheKey = char + font;\n        if (this._cache[cacheKey]) {\n            return this._cache[cacheKey];\n        }\n        const context = this._canvas.getContext('2d');\n        context.font = font;\n        const metrics = context.measureText(char);\n        const width = metrics.width;\n        this._cache[cacheKey] = width;\n        return width;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}